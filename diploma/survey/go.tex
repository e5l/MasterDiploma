\subsubsection{Язык Go}
Язык \lang{Go} компилируется в бинарный код. Интерфейсы в \lang{Go} являются структурными типами\cite{go}.

\begin{minted}{go}
type geometry interface {
  area() float64
  perim() float64
}

type rect struct {
  width, height float64
}

func (r rect) area() float64 {
  return r.width * r.height
}
func (r rect) perim() float64 {
  return 2*r.width + 2*r.height
}

func measure(g geometry) {
  fmt.Println(g)
  fmt.Println(g.area())
  fmt.Println(g.perim())
}

func main() {
  r := rect{width: 3, height: 4}
  measure(r)
}
\end{minted}

Рассмотрим реализацию структурных типов в компиляторе \tool{gccgo}. Так как \lang{Go} компилируется в бинарный код, разрешён вызов метода по указателю. Для каждого интерфейса компилируется специальный дескриптор типа. Каждый дескриптор содержит в себе список методов. Для каждого метода сохраняются: имя, сигнатура, указатель на реализацию. Объект содержит в себе ссылку на набор дескрипторов. По возможности, разрешение метода происходит во время компиляции. В ситуациях, когда ссылки на необходимые дескрипторы не получается разрешить во время компиляции, это происходит во время выполнения, при создании объекта.

Плюс подхода заключается в высокой скорости вызова и гибкости реализации для различных случаев использования. Такой подход не реализуем на \tool{JVM} из-за отсутствия прямого доступа к памяти.
