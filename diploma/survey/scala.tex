\subsubsection{Scala}
Рассмотрим реализацию протоколов в языке \lang{Scala}\cite{scala:structural}. \lang{Scala} компилируется в \tool{JVM} байткод. Реализацию можно разделить на 2 части: проверку типов при компиляции и генерация байткода для вызова метода.

Структурные типы являются обобщением типов \lang{Scala}. Проверка структурных типов изначально поддерживается компилятором с одним исключением: накладывается ограничение на явное наследование. Поэтому для проверки структурных типов достаточно отключить только одну проверку.

Рассмотрим генерацию байткода. В \lang{Scala} типы протоколов существуют только во время компиляции, в байткоде не генерируется новый тип. В процессе компиляции, тип протокола стираются до типа \term{Object}. Вызов метода у объекта стркутурного типа происходит с помощью специального механизма \method{applyDynamic}: для каждого места обращения к полю объекта генерируется статический метод. В статическом методе происходит поиск нужного метода. Сперва метод ищется в кэше, затем с помощью рефлексии. Так как внутри вызова может произойти исключительная ситуация, в этом методе происходит обработка исключения и разворачивание исходного исключения из \term{InvokationTargetException}. Таким образом вызов дополнительного метода выглядит прозрачно для пользователя. В реализации используют кэширование для всех найденных методов. В качестве кэша используют ссылочный список, где сохраняют каждый увиденный тип. В связи с тем что во время выполнения отсутствуют типы - запрещено создание протоколов с параметрическим типом или использование в протоколах внешних параметрических типов.

Внимательное тестирование подхода, используемого в \lang{Scala} показало что есть возможность написать код, порождающий некоректное поведение и ошибку времени выполнения, несмотря на корректность синтаксиса. Такое поведение связано с использованием примитивных типов в параметрических классах:

\begin{minted}
[frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos]
{scala}
class Impl[T] {
  def x(i: T): T = i
}

class Main {
  type Proto = { def x(i: Int): Int }

  def foo(arg: Proto) {
    print(arg.x(42))
  }

  def main(args: Array[String]) {
    foo(Impl[Int]())
  }
}
\end{minted}

С точки зрения языка \lang{Scala} такой код является корректным. Он проходит проверку типов и компиляцию, но во время выполнения происходит искючительная ситуация. Причиной этому является не совпадение типов методов. Во время генерации класса \term{Impl} тип \term{T} становится наиболее общим типом \term{Object}. В то же время для вызова в методе foo сгенерировался метод ищущий функции с типом \term{Int}. Поэтому в во время выполнения нужная функция в объекте \term{Impl} отсутствует и происходит исключение.

Для того чтоб обойти проверки модификаторов доступа каждый раз выставляется флаг модификации доступа. Исключения связанные с модификаторами доступа игнорируются.
