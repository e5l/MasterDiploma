\section{Особенности реализации}

\subsection{Компилция}
В процессе компиляции необходимо выполнить проверку типов и сгенерировать код для выполнения. Как было отмечено ранее в компиляторе реализована поддержка двух независимых подходов: через рефлексию и с помощь библиотеки invoke.

\subsection{Разрешение перегрузок}
Рассмотрим проблему несовпадения типов при использовании примитивных типов. Поиск методов выполняется по точному типу функции. Мы проверяем что необходимый метод существует во время компиляции. Проблема возникает в том что при трансляции конечные типы не совпадают. Данную проблему можно решить во время выполнения. Для этого необходимо изменить поиск метода из библиотеки на алгоритм разрешения перегрузок во время выполнения.

\paragraph{Проверка типов}
Проверка типов одинакова для обоих подходов. Чтобы проверить являетс ли тип подтипом протокола выполняется поиск каждого метода протокола в необходимом типе. В случае присутствия шаблонных параметров происходит их подстановка. Проверка наличия подходящего метода схожа с аналогичной проверкой возможности переопределения метода при наследовании: у методов должны совпадать имя и тип. Теоретически возможна реализация более конкретная реализация протокола: когда типы аргументов методов в протоколе являются подтипами соответствующих аргументов в типе объекта, но данный случай довольно редкий и зарещён для более предсказуемого поведения.

\paragraph{Генерация кода}
Для каждого места вызова на уровне пакета генерируется специальный статический метод, который в зависимости от типа реализации возвращает либо объект типа Method для рефлексии, либо объект типа MethodHandle для библиотеки invoke. Было принято решение использовать invokedynamic для двух решений для генерации статического объекта типа ProtocolCallSite, привязанного к месту вызова на уровне виртуальной машины. Этот объект был добавлен в библиотеку времени выполнения. В нём реализована логика поиска метода и кэширование. После инструкции invokedynamic на полученном объекте вызывается поиск метода.

\subsubsection{Поддержка времени выполнения}
Для поиска и кэширования метода в во время выполнения в стандартную библиотеку был добавлен класс ProtocolCallSite. Основная функциональность данного класса - поиск метода. Имя и тип вызываемого метода был передан при создании экзэмпляра метода. Но как было замечено ранее тип реального метода может отличаться от вызываемого с точностью до стираемых и примитивных типов. Поэтому поиск метода происходит с помощью библиотеки рефлексии и алгоритма выбора перегрузки.

\paragraph{Выбор подходящего типа}
Поиск метода связан с решением некоторого количества проблем. Рассмотрим дизайн типичного библиотечного интерфейса List. Интерфейс класса объявлен публичным. Однако библиотечные методы(например Arrays.asList) возвращают экземпляр приватного класса, приведённый к типу интерфейса. При обращении к полю class данного объекта получаем ссылку на информацию о приватном классе. Если попытаться вызвать метод это класса произойдёт исключение SecurityException.

Аналогичную проблему в Scala решают с помощью смены модификатора доступа. Данное решение является кандитатом на исключение из спецификации, поэтому является неприемлимым.

Заметим что пользователю доступен метод, значит должен существовать доступный пользователю тип, на котором можно сделать вызов. Так же очевидно что доступный тип является надтипом полученного нами типа. Поэтому задача сводится к следующей: найти ближайший подходящий доступный метод среди типа и его надтипов. Данная задача решается с помощью объхода иерархии наследования в ширину и запуском механизма выбора перегрузки дял каждого встреченного типа.

\paragraph{Алгоритм выбора перегрузки}
Рассмотрим процесс выбора подходящего метода. Среди всех методов с необходимым именем, оставляем методы доступные для вызова пользователем. Для каждого такого метода считаем вектор расстояния по типам аргументов. В качестве образцового вектора используем тот, что был сохранён во время компиляции. Для оценки расстояния между аргументами используем следующую градацию:
\begin{itemize}
    \item Точное совпадение
    \item Совпадение с точностью до оборачивания примитивных типов
    \item Возможность присвоить объект необходимого типа в объект типа в аргументах
\end{itemize}

Среди всех методов выбираем тот, у которого в векторе все компоненты минимальны. Наличие и единственность такого метода гарантируется в процессе компиляции.

\subsubsection{Кэш}

\subsubsection{Опции компиляции}
