\subsection{Реализация протоколов в компиляторе Kotlin}
В данном разделе будет рассказано о деталях реализации протоколов в компиляторе \lang{Kotlin}. Сперва рассмотрена основная функциональность реализации, рассказано как решены проблемы встреченные в других реализациях. Затем будет рассказано про структуру и особенность реализации функциональности в самом компиляторе и стандартной библиотеке.

Для поддержки протоколов в компиляторе был введён новый тип интерфейсов и добавлено ключевое слово \operator{protocol} со следующим синтаксисом:

\begin{minted}{kotlin}
protocol interface Proto {
  fun id(i: Int): Int
}

class Impl {
  fun id(i: Int): Int {
    return i
  }
}

fun foo(arg: Proto) {
  println(arg.id(42))
}

foo(Impl())
\end{minted}

Таким образом протоколы объявляются как самостоятельный тип.

В то же время отключён синтаксис для определение реализаций методов по умолчанию и указания значений аргументов по умолчанию.

\subsubsection{Выбор метода}
При приведении обычного объекта к типу протокола происходит проверка наличия всех методов протокола в объекте во время компиляции. В случае если не существует метода с необходимым возвращаемым значением, но существует метод с более конкретным типом возвращаемого значения, то он будет счиаться подходящим.

\subsubsection{Наследование и наличие методов}
Помимо неявного приведения типа к типу протокола, возможно явное указание типа протокола в качестве родительского типа. В таком случае реализация класса наследника будет проверена во время компиляции типа на наличие необходимых методов. Так же возможно указание нескольких протоколов в качестве базовых классов.

\subsubsection{Исключения}
Вызов метода протокола отличается от вызова обычного метода. Некоторые реализации могут предполагать оборачивание исключения в вспомогательный класс. В случае если в методе протокола происходит исключение, оно будет передано без оборачивания не зависимо от типа реализации протокола.

\subsubsection{Типовые параметры}
В отличии реализаций протоколов для других \tool{JVM} языков, протоколы в \lang{Kotlin} полностью поддерживают работу с типовыми параметрами как и обычные типы. Протокол может являться как и типовым аргументом, так и самостоятельно содержать типовые параметры. Более того реализация параметризованного класса может являться подтипом непараметризованного протокола и наоборот: реализация непараметризованного класса может быть подтипом параметризованного протокола с подставленным типом.

\subsubsection{Примитивные типы и перегрузки методов}
Реализация протоколов в \lang{Kotlin} полностью поддерживает методы с примитивными типами. Более того возможны перегрузки методов по ссылочным и примитивным типам: к примеру методы с аргументом \term{Int} и \term{Int?} являются разными методами не зависимо от реализации протокола. Данное поведение актуально в случае если в протоколе могут присутствовать метод с типовым параметром.
\begin{minted}{kotlin}
protocol interface Foo<T> {
  fun x(arg: T): T
}

class X {
  fun x(arg: Int) = arg + 1
  fun x(arg: Int?) = arg!! + 2
}

...
val first: Foo<Int> = X()
val second: Foo<Int?> = X()
\end{minted}
При вызове метода у первого объека будет вызван метод с \term{Int}, у второго будет вызван метод с \term{Int?}.

Помимо перечисленного выше поддерживается задание отношения на типовых параметрах как на обычных типах так и на протоколах.

\paragraph{Операторы проверки и приведения типа}
Для обычных типов в \lang{Kotlin} разрешено приведение или проверка любого объекта к любому типу. В большинстве случаев объекты реализующие протоколы не являются типами протоколов с точки зрения \tool{JVM}. С такой данной точки зрения возможно два поведения: реальная проверка типов инструкцией \tool{JVM} либо проверка соответствию протоколов во время выполнения. Оба способа возможно реализовать практически. С точки зрения пользователя каждое из поведений может являться не ожидаемым, поэтому было принято решение запретить использование протоколов в правой части операторов \operator{as} и \operator{is}. В тоже время разрешено присваивание объекта обычного типа к типу протокола если проверка ограничений на тип проходит во время компиляции.

Если извесен исходный тип объекта типа протокола, то можно выполнить приведение типов с помощью встроенных операторов. Так же можно выполнить проверку типов на объекте типа протокола.

Таким образом существует возможность перехода от обычных типов к протоколам и от протоколов к обычным типам.
