\section{Качественное сравнение}
Одной из важнейших характеристик в реализации протоколов является выразительность получившегося решениям в языке. Иными словами интерес представляет мощность полученной конструкции. Подобное сравнение ранее приводилось для реализации протоколов в языке \lang{Whiteoak}\cite{whiteoak}. Функциональность приведённой реализации не зависит от опций компиляции. Подходы реализации для разных платформ существенно отличаются, поэтому в контексте рассмотренного решения интересно сравнение реализация протоколов для языков платформы \tool{JVM}. Сравнение особенностей использования протоколов приведено в таблице \ref{features_comparison}.

\begin{table}[htb]
  \begin{center}
    \begin{tabular}{|c|c|c|c|} \hline
      Критерий & Scala & Whiteoak & Kotlin \\ \hline
      Объявление метода & $+$ & $+$ & $+$ \\ \hline
      Определение метода & $-$ & $+$ & $-$ \\ \hline
      Параметрический тип & $-$ & $-$ & $+$ \\ \hline
      Функция с параметрическим аргументом & $+$ & $-$ & $+$ \\ \hline
      Внешний типовой параметр & $-$ & $-$ & $+$ \\ \hline
      Рекурсивный тип & $-$ & $+$ & $+$ \\ \hline
      Ограничения на типовой параметр & $-$ & $-$ & $+$ \\ \hline
      Типовые операторы & $+$ & $+$ & $+$ \\ \hline
      Корректная работа с примитивными типами & $-$ & $+$ & $+$ \\ \hline
      Раздельная компиляция & $+$ & $+$ & $+$ \\ \hline
      Сохранение идентичности & $+$ & $+$ & $+$ \\ \hline
      Объявление конструктора & $-$ & $+$ & $-$ \\ \hline
    \end{tabular}
    \caption{Сравнение функциональной выразительности языков}
    \label{features_comparison}
  \end{center}
\end{table}

Из сравнения видно, что выразительность решений схожа в основной функиональности. Однако с помощью решения описаного в работе удалось преодолеть недостатки в выразительности, присутствующие в других языках в достаточно строгих условиях: сохранения идентичности и разельной компиляциию. Одной из ключевых осбенностей является поддержка работы с параметрическими типами. Это существенно расширяет контекст использования протоколов. Помимо этого рассмотренный подход позволяет избежать некорректного поведения при использовании функций с аргументами примитивных типов.
