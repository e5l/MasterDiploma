\section{Особенности реализации}
Реализация протоколов в компиляторе разделяется на две части: генерация кода и стандартная библиотека.

\subsection{Компиляция}
В процессе компиляции необходимо выполнить проверку типов и сгенерировать код для выполнения. Как было отмечено ранее в компиляторе реализована поддержка двух независимых подходов: через рефлексию и с помощь библиотеки вызовов.

\subsubsection{Разрешение перегрузок}
Рассмотрим проблему несовпадения типов при использовании примитивных типов. Поиск методов выполняется по точному типу функции. Мы проверяем что необходимый метод существует во время компиляции. Проблема возникает в том что при трансляции конечные типы не совпадают. Данную проблему можно решить во время выполнения. Для этого необходимо изменить поиск метода из библиотеки на алгоритм разрешения перегрузок во время выполнения.

\subsubsection{Проверка типов}
Проверка типов одинакова для обоих подходов. Чтобы проверить являетс ли тип подтипом протокола выполняется поиск каждого метода протокола в необходимом типе. В случае присутствия шаблонных параметров происходит их подстановка. Проверка наличия подходящего метода схожа с аналогичной проверкой возможности переопределения метода при наследовании: у методов должны совпадать имя и тип. Теоретически возможна реализация более конкретная реализация протокола: когда типы аргументов методов в протоколе являются подтипами соответствующих аргументов в типе объекта, но данный случай довольно редкий и зарещён для более предсказуемого поведения.

\subsubsection{Генерация кода}
Для каждого места вызова на уровне пакета генерируется специальный статический метод, который в зависимости от типа реализации возвращает либо объект типа \term{Method} для рефлексии, либо объект типа \term{MethodHandle} для библиотеки вызовов. Было принято решение использовать инструкцию \operator{invokedynamic} для двух решений для генерации статического объекта типа \term{ProtocolCallSite}, привязанного к месту вызова на уровне виртуальной машины. Этот объект был добавлен в библиотеку времени выполнения. В нём реализована логика поиска метода и кэширование. После инструкции \operator{invokedynamic} на полученном объекте вызывается поиск метода.

\subsection{Поддержка времени выполнения}
Для поиска и кэширования метода в во время выполнения в стандартную библиотеку был добавлен класс \term{ProtocolCallSite}. Основная функциональность данного класса - поиск метода. Имя и тип вызываемого метода был передан при создании экзэмпляра метода. Но как было замечено ранее тип реального метода может отличаться от вызываемого с точностью до стираемых и примитивных типов. Поэтому поиск метода происходит с помощью библиотеки рефлексии и алгоритма выбора перегрузки.

\subsubsection{Выбор подходящего типа}
Поиск метода связан с решением некоторого количества проблем. Рассмотрим дизайн типичного библиотечного интерфейса \term{List}. Интерфейс класса объявлен публичным. Однако библиотечные методы(например \term{Arrays.asList}) возвращают экземпляр приватного класса, приведённый к типу интерфейса. При обращении к полю \term{class} данного объекта получаем ссылку на информацию о приватном классе. Если попытаться вызвать метод это класса произойдёт исключение \term{SecurityException}.

Аналогичную проблему в \lang{Scala} решают с помощью смены модификатора доступа. Данное решение является кандитатом на исключение из спецификации, поэтому является неприемлимым.

Заметим что пользователю доступен метод, значит должен существовать доступный пользователю тип, на котором можно сделать вызов. Так же очевидно что доступный тип является надтипом полученного нами типа. Поэтому задача сводится к следующей: найти ближайший подходящий доступный метод среди типа и его надтипов. Данная задача решается с помощью объхода иерархии наследования в ширину и запуском механизма выбора перегрузки дял каждого встреченного типа.

\subsubsection{Алгоритм выбора перегрузки}
Рассмотрим процесс выбора подходящего метода. Среди всех методов с необходимым именем, оставляем методы доступные для вызова пользователем. Для каждого такого метода считаем вектор расстояния по типам аргументов. В качестве образцового вектора используем тот, что был сохранён во время компиляции. Для оценки расстояния между аргументами используем следующую градацию:
\begin{itemize}
    \item Точное совпадение
    \item Совпадение с точностью до оборачивания примитивных типов
    \item Возможность присвоить объект необходимого типа в объект типа в аргументах
\end{itemize}

Среди всех методов выбираем тот, у которого в векторе все компоненты минимальны. Наличие и единственность такого метода гарантируется в процессе компиляции.

\subsubsection{Кеширование результатов поиска метода}
Самый частый сценарий использования протокола это вызов метода. Написание прототипа показало, что процедура вызова метода протокола выполняются заметно дольше чем вызов аналогичного метода через интерфейс. Вызов метода протокола состоит из двух частей: первая часть заключается в выборе наиболее подходящего метода в объекте. Вторая в укладке аргументов и непосредственном вызове. Заметим что результат поиска метода для одного типа метода и одного типа объекта будет всегда одинаков. Это значит что можно запомнить результат поиска. Тогда выполнять поиск метода прийдётся только при первом вызове на одном типе.

Заметим что во время компиляции одного места вызова тип вызываемого метода известен и не будет изменён во время выполнения.

Будем предполагать, что вызовов на протоколах будет происходить больше чем типов объектов на которых происходит вызов в одном месте вызова. Данное предположение вполне оправдано: оно начинает выполняться когда на одном типе дважды происходит вызов.

Исходя из сделанных предположений можно сделать вывод о том что использование кеша для хранения результата поиска может быть оправданно в случае если обращение к кешу происходит быстрее чем поиск метода.

Для поиска оптимального кеша было реализовано 3 варианта кеширования:
\begin{itemize}
  \item Ссылочный список
  \item Циклический массив с вытеснением последнего добавленного элемента
  \item Хеш-таблица
\end{itemize}

Ключём для поиска является объект класса. Значением - экземпляр класса \term{Method} или \term{MethodHandle} в зависимости от выбранной имплементации. Размер кеша задаётся с помощью опций компиляции. По умолчанию размер кеша не ограничен(за исключением циклического списка, размер по умолчанию которого равен 20 элементам). Сравнение производительности кешей будет приведено в разделе \ref{measurements}.

\subsubsection{Вызов метода из нескольких потоков}
Механизм вызова метода объекта в \tool{JVM} не зависит от того из скольки потоков происходят вызовы. Поэтому одним из требований вызова является вызов метода из нескольких потоков. Отличие вызова метода протокола от вызова обычного метода заключается в наличии изменяемого состояния: кеша. Это значит что если работа с кешом является потокобезопасной, то вызов метода протокола тоже является потокобезопасным.

В нашем решении было рассмотрено 2 подхода к обеспечению потокобезопасности кеша: \term{synchronized} конструкция и \term{read-write} блокировка. Конструкция \term{synchronized} является флагом метода и обеспечивает гарантию того, что помеченный метод исполняется только в одном потоке. Блокировка \term{read-write} реализована с помощью класса стандартной библиотеки \term{ReentrantReadWriteLock}\cite{jvm:rwlock}. Кеш протоколов состоит из двух методов, первый метод для поиска, второй для добавления элемента. Следовательно можно производить раздельную блокировку для чтения и записи.

Каждый из подходов имеет свои преимущества и недостатки. Например в \term{synchronized} методов блокировка может не производиться если работает только один поток, помимо этого может выполняться оптимистичная блокировка\cite{jvm:optimistic_lock}. В то же время \term{read-write} блокировка работает оптимально в случае если происходят только чтения из кеша. Таким образом, если метод протокола уже был найден, блокировки не происходит.
