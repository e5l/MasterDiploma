\subsection{Реализация протоколов в компиляторе Kotlin}

Поддержка протоколов в компиляторе заключается в введении способа объявить тип протокола и определении набора правил для приведения и вызове метода. Для того, чтобы объявить тип протокола в компиляторе был введён новый тип интерфейса. Если перед именем интерфейса указать ключевое слово \term{porotocol}, интерфейс будет автоматически считаться объявлением протокола типа:

\begin{minted}{kotlin}
protocol interface Proto {
  fun id(i: Int): Int
}

class Impl {
  fun id(i: Int): Int {
    return i
  }
}

fun foo(arg: Proto) {
  println(arg.id(42))
}

foo(Impl())
\end{minted}

Объявленный протокол может использоваться так же, как и обычный интерфейс: являться типовым параметром, быть родительским классом и т.д. Однако информация о нём отсутствует во время выполнения: у классов, явно реализующих тип протокола, он отсутствует в списке интерфейсов.

Для того чтобы избежать неоднозначного поведения, в протоколах отключены методы и аргументы по умолчанию.

\subsubsection{Выбор метода}

В зависимости от способов объявления и реализации протокола, у разных типов, приведённых к протоколу, могут быть разные методы в одном месте вызова. Помимо этого, в языке \term{Kotlin} поддерживаются перегрузки методов с разным числом и типом параметров. Подобные ситуации могут приводить к неоднозначности в выборе метода.

Примером такой ситуации может послужить использование параметрических типов в протоколе:
\begin{minted}{kotlin}
protocol interface Sample<T> {
  fun foo(arg: T)
}

class X {
  fun foo(i: Int)
  fun foo(i: Int?)
}

...
val x = X()
val first: Sample<Int> = x
val second: Sample<Int?> = x

\end{minted}

На уровне виртуальной машины отсутствует информация о типовых параметрах. В случае метода \term{foo(Int)} транслированный тип будет примитивным, а в \term{foo(Int?)} ссылочным. Если бы тип \term{Sample} не был протоколом, то из двух ссылок \term{first} и \term{second} был бы доступен метод \term{foo(Int?)}. В случае протокола, будет запущен алгоритм выбора метода, который выберет наиболее близкий по типам метод в каждом случае. В данном случае, из ссылки \term{first} доступен для вызова метод \term{foo(Int)}, а из ссылки \term{second} доступен \term{foo(Int?)}.

Алгоритм выбора метода независимо запускается во время компиляции и во время выполнения. Выбор метода во время компиляции необходим при приведении типа объекта к типу протокола. В данном случае, происходит проверка наличия всех методов протокола в объекте во время компиляции. В случае, если не существует метода с необходимым возвращаемым значением, но существует метод с более конкретным типом возвращаемого значения, то он будет считаться подходящим.

Во время выполнения, выбор метода происходит непосредственно во время вызова. Так как представление компилятора и виртуальной машины о методах различны, сохранить результат выбора во время компиляции как есть не представляется возможным. Данный метод гарантировано существует, так как это было проверено на этапе компиляции.

\subsubsection{Исключения}
Вызов метода протокола отличается от вызова обычного метода. Некоторые реализации могут предполагать оборачивание исключения в вспомогательный класс. В случае, если в методе протокола происходит исключение, оно будет передано без оборачивания, независимо от типа реализации протокола.

\subsubsection{Типовые параметры}
В отличии от реализаций протоколов для других \tool{JVM} языков, протоколы в \lang{Kotlin} полностью поддерживают работу с типовыми параметрами, так же, как и обычные типы. Протокол может являться, как типовым аргументом, так и самостоятельно содержать типовые параметры. Более того, реализация параметризованного класса может являться подтипом непараметризованного протокола, и наоборот: реализация не параметризованного класса может быть подтипом параметризованного протокола с подставленным типом.

\paragraph{Операторы проверки и приведения типа}
Для обычных типов в \lang{Kotlin} разрешено приведение или проверка принадлежности любого объекта к любому типу. В большинстве случаев, объекты, реализующие протоколы, не являются типами протоколов, с точки зрения \tool{JVM}. В таком случае возможно два поведения: реальная проверка типов инструкцией \tool{JVM}, либо проверка соответствия протоколу во время выполнения. С точки зрения пользователя, каждое из поведений может являться не ожидаемым, поэтому было принято решение запретить использование протоколов в правой части операторов \operator{as} и \operator{is}. В тоже время, разрешено присваивание объекта обычного типа к типу протокола, если проверка ограничений на тип проходит во время компиляции. Если известен исходный тип объекта типа протокола, то можно выполнить приведение типов с помощью встроенных операторов. Так же можно выполнить проверку типов на объекте типа протокола. Таким образом существует возможность перехода от обычных типов к протоколам и от протоколов к обычным типам.
