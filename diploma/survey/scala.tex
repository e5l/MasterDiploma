\subsubsection{Scala}
Рассмотрим реализацию протоколов в языке программирования \lang{Scala}\cite{scala:structural}. \lang{Scala} компилируется в \tool{JVM} байткод. Реализацию можно разделить на 2 части: проверку типов при компиляции и генерация байткода для вызова метода.

Типы протоколов являются обобщением типов \lang{Scala}. Проверка типов протоколов изначально поддерживается компилятором, с одним исключением: накладывается ограничение на явное наследование. Поэтому, для проверки типов достаточно отключить только проверку указания отношения наследования.

Рассмотрим генерацию байткода. В \lang{Scala} типы протоколов существуют только во время компиляции, в байткоде не генерируется новый тип. В процессе компиляции, тип протокола стираются до типа \term{Object}. Вызов метода у объекта типа протокола происходит с помощью специального механизма \method{applyDynamic}: для каждого места обращения к полю объекта генерируется статический метод. В статическом методе происходит поиск нужного метода. Сперва метод ищется в кеше\cite{9780262033848}, затем с помощью рефлексии. Так как внутри вызова может произойти исключительная ситуация, в этом методе происходит обработка исключения и разворачивание исходного исключения из \term{InvokationTargetException}. Таким образом, вызов дополнительного метода выглядит прозрачно для пользователя. В реализации используют кеширование для всех найденных методов. В качестве кеша используют ссылочный список, где сохраняют каждый увиденный тип. В связи с тем, что во время выполнения отсутствуют типы - запрещено создание протоколов с параметрическим типом или использование в протоколах внешних параметрических типов.

Внимательное тестирование подхода, используемого в \lang{Scala} показало, что есть возможность написать код, порождающий некоректное поведение и ошибку времени выполнения, несмотря на корректность синтаксиса. Такое поведение связано с использованием примитивных типов в параметрических классах:

\begin{minted}{scala}
class Impl[T] {
  def x(i: T): T = i
}

class Main {
  type Proto = { def x(i: Int): Int }

  def foo(arg: Proto) {
    print(arg.x(42))
  }

  def main(args: Array[String]) {
    foo(Impl[Int]())
  }
}
\end{minted}

С точки зрения языка \lang{Scala}, такой код является корректным. Он проходит проверку типов и компиляцию, но во время выполнения происходит исключительная ситуация. Причиной этому является несовпадение типов методов. Во время генерации класса \term{Impl} тип \term{T} становится наиболее общим типом \term{Object}. В то же время, для вызова в методе \term{foo} сгенерировался метод, ищущий функции с типом \term{Int}. Поэтому, во время выполнения нужная функция в объекте \term{Impl} отсутствует и происходит исключение.

Для того чтобы обойти проверки модификаторов доступа, каждый раз выставляется флаг модификации доступа. Исключения, связанные с модификаторами доступа, игнорируются.
