\section{Особенности реализации}
Реализация протоколов в компиляторе разделяется на две части: генерация кода и стандартная библиотека.

\subsection{Компиляция}
В процессе компиляции необходимо выполнить проверку типов и сгенерировать код для выполнения. Как было отмечено ранее в компиляторе реализована поддержка двух независимых подходов: через рефлексию и с помощь библиотеки вызовов.

\subsubsection{Разрешение перегрузок}
Рассмотрим проблему несовпадения типов при использовании примитивных типов. Поиск методов выполняется по точному типу функции. Мы проверяем что необходимый метод существует во время компиляции. Проблема возникает в том что при трансляции конечные типы не совпадают. Данную проблему можно решить во время выполнения. Для этого необходимо изменить поиск метода из библиотеки на алгоритм разрешения перегрузок во время выполнения.

\subsubsection{Проверка типов}
Проверка типов одинакова для обоих подходов. Чтобы проверить являетс ли тип подтипом протокола выполняется поиск каждого метода протокола в необходимом типе. В случае присутствия шаблонных параметров происходит их подстановка. Проверка наличия подходящего метода схожа с аналогичной проверкой возможности переопределения метода при наследовании: у методов должны совпадать имя и тип. Теоретически возможна реализация более конкретная реализация протокола: когда типы аргументов методов в протоколе являются подтипами соответствующих аргументов в типе объекта, но данный случай довольно редкий и зарещён для более предсказуемого поведения.

\subsubsection{Генерация кода}
Для каждого места вызова на уровне пакета генерируется специальный статический метод, который в зависимости от типа реализации возвращает либо объект типа \term{Method} для рефлексии, либо объект типа \term{MethodHandle} для библиотеки вызовов. Было принято решение использовать инструкцию \operator{invokedynamic} для двух решений для генерации статического объекта типа \term{ProtocolCallSite}, привязанного к месту вызова на уровне виртуальной машины. Этот объект был добавлен в библиотеку времени выполнения. В нём реализована логика поиска метода и кэширование. После инструкции \operator{invokedynamic} на полученном объекте вызывается поиск метода.

\subsection{Поддержка времени выполнения}
Для поиска и кэширования метода в во время выполнения в стандартную библиотеку был добавлен класс \term{ProtocolCallSite}. Основная функциональность данного класса - поиск метода. Имя и тип вызываемого метода был передан при создании экзэмпляра метода. Но как было замечено ранее тип реального метода может отличаться от вызываемого с точностью до стираемых и примитивных типов. Поэтому поиск метода происходит с помощью библиотеки рефлексии и алгоритма выбора перегрузки.

\subsubsection{Выбор подходящего типа}
Поиск метода связан с решением некоторого количества проблем. Рассмотрим дизайн типичного библиотечного интерфейса \term{List}. Интерфейс класса объявлен публичным. Однако библиотечные методы(например \term{Arrays.asList}) возвращают экземпляр приватного класса, приведённый к типу интерфейса. При обращении к полю \term{class} данного объекта получаем ссылку на информацию о приватном классе. Если попытаться вызвать метод это класса произойдёт исключение \term{SecurityException}.

Аналогичную проблему в \lang{Scala} решают с помощью смены модификатора доступа. Данное решение является кандитатом на исключение из спецификации, поэтому является неприемлимым.

Заметим что пользователю доступен метод, значит должен существовать доступный пользователю тип, на котором можно сделать вызов. Так же очевидно что доступный тип является надтипом полученного нами типа. Поэтому задача сводится к следующей: найти ближайший подходящий доступный метод среди типа и его надтипов. Данная задача решается с помощью объхода иерархии наследования в ширину и запуском механизма выбора перегрузки дял каждого встреченного типа.

\subsubsection{Алгоритм выбора перегрузки}
Рассмотрим процесс выбора подходящего метода. Среди всех методов с необходимым именем, оставляем методы доступные для вызова пользователем. Для каждого такого метода считаем вектор расстояния по типам аргументов. В качестве образцового вектора используем тот, что был сохранён во время компиляции. Для оценки расстояния между аргументами используем следующую градацию:
\begin{itemize}
    \item Точное совпадение
    \item Совпадение с точностью до оборачивания примитивных типов
    \item Возможность присвоить объект необходимого типа в объект типа в аргументах
\end{itemize}

Среди всех методов выбираем тот, у которого в векторе все компоненты минимальны. Наличие и единственность такого метода гарантируется в процессе компиляции.

\subsubsection{Кэш}
Самый частый сценарий использования протокола это вызов метода. Процедура вызова метода протокола выполняются заметно дольше чем вызов аналогичного метода через интерфейс. Вызов метода протокола состоит из двух частей: первая часть заключается в выборе наиболее подходящего метода в объекте. Вторая в укладке аргументов и непосредственном вызове. Заметим что результат поиска метода для одного типа метода и одного типа объекта будет всегда одинаков. Это значит что можно запомнить результат поиска. Тогда выполнять поиск метода прийдётся только при первом вызове на одном типе.

Заметим что во время компиляции одного места вызова тип вызываемого метода известен и не будет изменён во время выполнения.

Будем предполагать, что вызовов на протоколах будет происходить больше чем типов объектов на которых происходит вызов в одном месте вызова. Данное предположение вполне оправдано: оно начинает выполняться когда на одном типе дважды происходит вызов.

\subsubsection{Вызов метода из нескольких потоков}
