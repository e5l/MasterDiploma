\subsection{Виртуальная машина Java}
В данном разделе рассматриваются особенности разработки компилятора для виртуальной машины Java(далее JVM). 

% [https://en.wikipedia.org/wiki/Java_virtual_machine]
% [http://dmoztools.net/Computers/Programming/Languages/Java/Implementations/]

Виртуальная машина JVM - это часть JRE ответственная за исполнение программ. JVM представляет из себя абстрактную виртуальную машину, описанную спецификацией\cite{jvm:specification}. В спецификации описаны набор инструкций, модель памяти, формат исполняемых файлов, ожидаемое поведение. Это значит что существует много различных реализаций JVM для разных платформ: HotSpot, IcedTea, Viva, Azul и т.д. 

JVM является стековой машиной. Это значит что программы исполняемые программы используют стек для передачи параметров вызовов. Единицей исполнения является классфайл. Классфайлы собираются в архивы формата jar.

На уровне JVM реализуется большинство языковых инструментов: наследование, объявление статических полей и методов, набор примитивных типов, механизм исключений. Все классы находятся в общей иерархии наследования: существует класс Object от которого по умолчанию наследуется каждый класс.

\subsubsection{Байткод виртуальной машины}
Рассмотрим подробно структуру классфайла. Каждый классфайл содержит в себе описание одного класса. В каждом классе хранится набор его полей, методов и информация о базовом классе. С каждым полем и методом хранится их тип. Исходный код метода состоит из последовательности однобайтовых(реже двухбайтовых) инструкций. 

Все инструкции строго типизированы. Существует набор встроенных и можно определять пользовательские. Встроенные типы бывают двух видов: примитивные типы и ссылочные типы. Примитивные типы передаются по значению, работы с ними более оптимальна: виртуальной машине не нужно обращаться по ссылке. Набор примитивных типов заранее определён и не может быть изменён пользователем. Для каждого примитивного типа существует парный ссылочный тип, который используется в случаях, когда необходима передача по ссылке. Существуют следующие типы примитивных типов: int, boolean, short; парные ссылочные типы: Integer, Boolean, Short соответственно.

Рассмотрим имеющийся набор инструкций. В байткоде присутствуют инструкции для работы с локальными переменными, для создания объектов и примитивных типов, арифметические операции, инструкции для вызова методов, условные переходы. Стоит отметить что полностью отсутствуют любые инструкции для прямого доступа к памяти: нельзя взять указатель на определённый адрес, перейти к исполнению адреса или прочитать адрес. Виртуальная машина полностью скрывает детали реализации аппаратной части в которой работает.

На уровне JVM поддерживается номинальная система типов и отношение наследования. Для вызова метода необходимо знать тип объекта, в котором находится поле, имя метода и его сигнатуру. Для вызова методов используются инструкции семейства invoke. Существует несколько разных invoke-инструкций:
\begin{itemize}
    \item \textbf{invokespecial} используется для вызова конструкторов у не инициализированных объектов, обращения к приватным полям текущего объекта и обращение к полям базового класса
    \item \textbf{invokevirtual} используется для вызова методов у класса
    \item \textbf{invokestatic} используется для вызова статических методов
    \item \textbf{invokedynamic} используется для вызова различных методов, при этом механизм выбора метода определяется специальной функцией, которая передаётся в аргументах
\end{itemize}
Перед загрузкой класса виртуальная машина запустит верификатор, который проверит наличие методов и соответствие типов аргументов. Невозможно напрямую вызвать метод, если неизвестен реальный тип объекта.

Существует две стандартные библиотеки для вызова методов без информации о типе: библиотека рефлексии и библиотека invoke.
\paragraph{Рефлексия}
% проверить поле class
Существует способ узнавать содержимое классов и вызывать произвольные методы во время выполнения с помощью рефлексии\cite{jvm:reflection}. Во время выполнения из JVM можно получить информацию о том, какие методы присутствуют в конкретном объекте и их сигнатуру. У каждого объекта в JVM есть поле с именем class, откуда можно получить объект типа Class<?>. Он хранит множество дополнительной информации об объекте. В этом объекте есть методы для получения списка методов. С каждым методом хранится информация об имени и типе. Существует возможность вызвать полученный метод, при этом передав объект на котором производится вызов и массив типа Object с аргументами. Так как Object ссылочный тип, все примитивные аргументы оборачиваются. Поиск и вызов метода могут занимать длительное время: необходимо выполнить поиск по имени и выполнить проверку типов для всех аргументов. Если при вызове метода происходит исключительная ситуация, то метод порождает исключение типа InvocationTargetException причиной которого является исходное исключение.

% invokedynamic: boostrap method, lookup object, method handle
% рассказать про то что exception оборачивается
\paragraph{Библиотека invoke и JSR 292}
Для платформы JVM существует несколько динамических языков. Механизм рефлексии является медленным, поэтому разработчики платформы создали новую библиотеку invoke. С её помощью можно существенно упростить и ускорить код для вызова методов.

% JSR, MethodHandle
Рассмотрим подробнее инструкцию invokedynamic. Эта инструкция принимает на вход ссылку на специальный статический метод. Этот метод определяется разработчиком и вызывается только при первой интерпретации инструкции. Результат вызова этого метода сохраняется внутри виртуальной машины и не вычисляется при следующем обращении. Метод имеет специальную сигнатуру: ему передаётся специальный словарь, к которому можно сделать запрос на наличие определённого метода или поля у объекта. Таким образом можно получить функциональность схожую с рефлексией, но выполняющую поиск метода и проверку типов только один раз.