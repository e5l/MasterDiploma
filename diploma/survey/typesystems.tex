\subsection{Структурная и номинальная типизации}
В данном разделе рассмотрены основы структурной типизации и номинальной типизации.

\paragraph{Номинальная типизация}
Номинальная типизация во многих языках реализованна с помощью механизма наследования\cite{book:pierce}. Пользователь явно указывает наследников каждого класса. Исходя из этого, компилятор разрешает вызовы методов. В некоторых языках происходят опциональные проверки перегрузок.

У номинальной типизации существует множество плюсов. В первую очередь, она является интуитивной для программиста: программист знает какие классы могут быть переданы и явно поддерживает иерархию наследования. В процессе компиляции можно использовать информацию о наследовании и расположить поля объектов так, чтоб к ним удобно было обращаться по смещению, тем самым существенно уменьшается время доступа к полям объектов.

Проверка типов при номинальной типизации сводится к обходу направленного ациклического графа иерархии типов. Связывание двух объектов разных типов является корректным, если существует путь из типа присваиваемого объекта к типу целевого объекта. Граф иерархии строится из отношений наследования: типы являются вершинами, отношение "наследник-родитель" задаёт рёбра.

Подведя итог, можно привести следующие плюсы номинальной типизации:
\begin{itemize}
    \item быстрее во время выполнения;
    \item помогает избежать случайных отношений;
    \item проще объявлять рекурсивные типы;
    \item быстрее проверять.
\end{itemize}

\paragraph{Структурная типизация}
Структурная типизация основывается на содержимом типа\cite{book:pierce}. Имя типа имеет меньшее значение.

Тип \term{A} является подтипом типа \term{B}, если выполнены следующие условия:
\begin{itemize}
    \item \term{A} содержит все именованные методы \term{B};
    \item Тип каждого метода \term{A} является подтипом соответствующего метода в \term{B}.
\end{itemize}

Как следствие, любой тип является подтипом пустого типа. Типы функций являются подтипами только при полном совпадении типов аргументов и возвращаемого значения.

Одним из основных минусов структурной типизации является семантическая неочевидность: два не связанных по смыслу типа могут иметь схожую структуру. Благодаря этому, структурная типизация менее распространена. В основном она используется в функциональных языках программирования, а так же в некоторых скриптовых языках как альтернатива динамической. Структурная типизация схожа с динамической, но является более безопасной: гарантия наличия полей и методов обеспечивается на этапе компиляции.

У структурной типизации есть свои плюсы. Она является более гибкой: имена типов не имеют значения, имеет значение только содержимое. Два типа с одинаковым содержимым считаются эквивалентными. Проверка типов при структурной типизации: проверка вложенности двух типов.

Плюсы структурной типизации:
\begin{itemize}
    \item замкнуты: тип содержит в себе всё описание структуры;
    \item имя типа имеет символический характер и не влияет на отношение подтипизации.
\end{itemize}

Несмотря на то, что повсеместное использование структурной типизации часто не оправдано, существуют ситуации, в которых необходимо её использование. К примеру с помощью структурной типизации можно писать обощённые функции, которые работают с любыми объектами, обладающими заданным набором методов \cite{JOT:issue_2008_01/article4}.
