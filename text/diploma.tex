\documentclass{spbau-diploma}
\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра математических и информационных технологий},
    title              = {Протоколы/Структурные типы в Kotlin},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {master},
    position           = {студента},
    group              = SE,
    author             = {Сташевский Леонид Евгеньевич},
    supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Жарков Д.\,Буква.},
    reviewerPosition   = {ст. преп.},
    reviewer           = {Привалов А.\,И.},
    chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
    chairHead          = {Омельченко А.\,В.},
    % university = {САНКТ-ПЕТЕРБУРГСКИЙ АКАДЕМИЧЕСКИЙ УНИВЕРСИТЕТ},
    % faculty = {Центр высшего образования},
    % city = {Санкт-Петербург},
    % year             = {2013}
}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}
В современных языках программирования существует много способов вводить отношение подтипизации. Самый популярный подход - это отношение наследования или номинальная типизация. В наследовании программист сам решает какой объект является наследником другого. На языке типов это означает что тип наследника является подтипом типа предка. Существует вариант автоматического вывода отношения подтипизации на основе интерфейса объектов. В процессе сборки, компилятор проверяет что используемый тип удовлетворяет ограничениям указанного типа. Такая система типов называется структурной. Такая типизация встречается в некоторых языках программирования: Go, семейство ML.

Номинальная типизация является простой, а следовательно и более распространённой. Она используется в таких языках как Java, C++, Kotlin. Вместе с простотой на программиста накладываются ограничения: при взаимодействии с кодом, который уже скомпилирован в библиотеку. Типы находящиеся в других модулях нельзя добавить в иерархию наследования, поэтому для них приходится писать и поддерживать типы-обёртки.

Существует другое решение, сохраняющее простоту и выразительность. Можно использовать номинальную типизацию в большинстве случаев, а там где необходима гибкость - использовать структурный тип. Такой подход сохранит совместимость с уже написанным кодом и позволит писать более выразительный код. В языке с номинальными типами структурные типы называют протоколами.

На данный момент набирает популярность язык Kotlin. В нём используется номинальная система типов. На момент написания его основной целевой платформой является виртуальная машина языка Java. Существуют несколько языков на основе JVM, в которых поддерживаются структурные типы. Например они поддерживаются языками Scala, Whiteoak.

\section*{Постановка задачи}
Цель данной работы - реализация поддержки протоколов в языке Kotlin. Для её достижения необходимо выполнить следующие задачи:
\begin{itemize}
    \item Исследование способов реализации структурных типов в JVM, существующие реализации и выяснение ограничений
    \item Реализация и тестирование прототипа
    \item Реализация проверки типов в компиляторе языка Kotlin
    \item Генерация кода для компилятора
    \item Поддержка раздельной компиляции
    \item Поддержка многопоточности
    \item Измерение производительности и оптимизация
\end{itemize}

\section{Обзор предметной области}
% структурная типизация и механизм проверки типов, приводится сравнение существующих реализаций протоколов в других языках программирования.
\subsection{Виртуальная машина Java}
% [https://en.wikipedia.org/wiki/Java_virtual_machine]
% [http://dmoztools.net/Computers/Programming/Languages/Java/Implementations/]
В данном разделе рассматриваются особенности разработки комилятора для виртуальной машины Java(далее JVM). JVM - абстрактная виртуальная машина и набор библиотек. Существует много различных реализаций JVM для разных платформ: HotSpot, IcedTea, Viva, Azul и т.д. Все реализации полностью или частично придерживаются спецификации JVM. В ней описаны набор инструкций и их ожидаемое поведение, модель памяти, формат исполняемых файлов и т.п. JVM является стековой машиной: операнды методов и результат вызовов распологаются на стеке.
% ссылка на спеку

JVM поддерживает раздельную компиляцию. Единицей компиляции является классфайл. В классфайле находится тип, с указанием родительского класса, информация о родительских интерфейсах, поля и методы. Код метода содержит последовательность инструкций виртуальной машины. Классфайлы собираются в архивы формата jar.

\subsubsection{Байткод виртуальной машины}
Исходный код метода состоит из последовательность однобайтовых(иногда двухбайтовых) инструкций. Присутствуют инструкции для работы с локальными переменными, создания объектов и примитивных типов, арифметические операции, инструкции для вызова метода, условные переходы. Отсутствуют инструкции для прямой работы с памятью: нельзя взять указатель на определённый адрес или перейти к исполнению адреса. Объекты передаются по ссылкам.

Все инструкции строго типизированы. Есть два вида типов: примитивные типы передающиеся по значению и ссылочные типы. Примитивные типы заранее определены в JVM, пользовательские примитивные типы создать нельзя. Для каждого примитивного типа существует парный ссылочный тип, который используется в особых случаях. Существуют следующие типы примитивных типов: int, boolean, short. Парные ссылочные типы: Integer, Boolean, Short соответственно. В языке Kotlin такое разделение отсутствует. Программист пользуется встроенным типом, какой тип использовать решает компилятор.

В JVM встроен механизм исключений. В любом месте кода может быть написана инструкция, обозначающая исключительную ситуацию. При выполнении такой инструкции исполнение будет передано ближайшему блоку обработки исключений подходящего типа.

Большинство методов в JVM виртуальные, так же поддерживаются статические методы.
На уровне JVM поддерживается номинальная система типов и отношение наследования. По умолчанию каждый класс наследуется от класса Object. Для вызова метода необходимо знать тип объекта, в котором находится поле, имя метода и его сигнатуру. Для вызова методов используются invoke-инструкции. Существует несколько разных invoke-инструкций:
\begin{itemize}
    \item \textbf{invokespecial} используется для вызова конструкторов у непроинициализированных объектов
    \item \textbf{invokevirtual} используется для вызова методов у класса,
    \item \textbf{invokestatic} используется для вызова статических методов
    \item \textbf{invokedynamic} используется для вызова различных методов, при этом механизм выбора метода определяется специальной функцией, которая передаётся в аргументах
\end{itemize}
Перед загрузкой класса виртуальная машина запустит верификатор, который проверит наличие методов и соответствие типов аргументов. Невозможно напрямую вызвать метод, если неизвесен реальный тип объекта.

\textbf{Рефлексия}

Существует способ узнавать содержимое классов и вызывать произвольные методы во время выполнения с помощью рефлексии. Во время выполнения из JVM можно получить информацию о том, какие методы присутствуют в конкретном объекте и их сигнатуру. По имени и точной сигнатуре получить ссылку на метод и по ней сделать вызов. Вызов происходит с помощью метода invoke класса Method. Данный метод принимает объект на котором происходит вызов(далее ресивер) и массив с аргументами. Поиск метода может занимать длительное время. Вызов метода происходит дольше чем вызов с помощью invokevirtual поскольку при каждом вызове происходит заворачивание аргументов в массив и проверка типов. Если при вызове метода происходит исключительная ситуация, то метод порождает исключение типа InvocationTargetException причиной которого является исходное исключение.

% invokedynamic: boostrap method, lookup object, method handle
% рассказать про то что exception оборачивается
\textbf{Инструкция invokedynamic}
% JSR, MethodHandle
Рассмотрим подробнее инструкцию invokedynamic. Эта инструкция принимает на вход ссылку на специальный статический метод. Этот метод определяется разработчиком и вызывается только при первой интерпретации инструкции. Результат вызова этого метода сохраняется внутри виртуальной машины и не вычисляется при следующем обращении. Метод имеет специальную сигнатуру: ему передаётся специальный словарь, к которому можно сделать запрос на наличие определённого метода или поля у объекта. Таким образом можно получить функциональность схожую с рефлексией, но выполняющую поиск метода и проверку типов только один раз.

\subsection{Структурная и номинальная типизации}
В данном разделе рассмотрены основы структурной типизации и номинальной типизации.

Номинальная типизация во многих языках реализованна с помощью механизма наследования. Пользователь явно указывает наследников каждого класса. Исходя из этого, компилятор разрешает вызовы методов. В некоторых языках происходят опциональные проверки перегрузок.

Плюсы номинальной типизации:
\begin{itemize}
    \item быстрее во время выполнения
    \item помогает избежать случайных отношений
    \item проще объявлять рекурсивные типы
    \item быстрее проверять
\end{itemize}

Структурная типизация является более гибкой. Тип $A$ является подтипом типа $B$ если выполнены следующие условия:
\begin{itemize}
    \item Тип $A$ и тип $B$ одинаковое количество полей
    \item $A$ содержит все именованные поля $B$
    \item Тип каждого поля $A$ является подтипом $B$
\end{itemize}
Типы функций являются подтипами только при полном совпадении типов аргументов и возвращаемого значения. Имена типов при этом не имеют значения: два типа с одинаковым содержимым. Проверка типов при структурной типизации: проверка вложенности двух типов.

Плюсы структурной типизации:
\begin{itemize}
    \item замкнуты: тип содержит в себе всё описание
    \item имя типа имеет символический характер и не влияет на отношение типизации
\end{itemize}

\subsection{Существующие реализации протоколов}
В этом разделе проведён анализ существующих реализация протоколов, приведены плюсы и минусы различных подходов. В качетве реализаций рассмотрены языки: Scala, Go и прототип Whiteoak.

\subsubsection{Scala}
Рассмотрим реализацию протоколов в языке Scala. Scala компилируется в JVM байткод. Реализацию можно разделить на 2 смысловые части: проверку типов при компиляции и генерация байткода для вызова метода.

В Scala используется модификация алгоритма Хиндли-Милнера для типизации. Модификация заключается в проверке отношения наследования, поэтому для работы протоколов достаточно отключить проверку явного наследования.

Рассмотри генерацию байткода. В Scala типы протоколов существуют только во время компиляции. В байткоде не генерируется новый тип. В процессе компиляции, тип протокола стираются до типа Object. Для каждого места обращения к полю объекта генерируется статический метод, который выполняет вызов необходимого метода. В статическом методе происходит поиск нужного метода для вызова через рефлексию. Так как внутри вызова может произойти исключительная ситуация, в этом методе происходит обработка исключения и разворачивание исходного исключения из InvokationTargetException. Таким образом вызов дополнительного метода выглядит прозрачно для пользователя. Поиск метода может быть долгим, поэтому в реализации скала используют кэширование для найденного метода найденного метода: сперва запрос идёт в кеш и вслучае неуспеха происходит поиск. В связи с тем что во время выполнения отсутствуют типы - запрещено создание generic протоколов или использование в протоколах generic типов.

Внимательное тестирование подхода, используемого в Scala показало что есть возможность написать код, порождающий некоректное поведение и ошибку времени выполнения, несмотря на внешнюю корректность синтаксиса. Такое поведение связано с использованием примитивных типов в generic классах:

\begin{minted}{scala}
class Impl[T] {
    def x(i: T): T = i
}

class Main {
    type Proto = { def x(i: Int): Int }

    def foo(arg: Proto) {
        print(arg.x(42))
    }
    def main(args: Array[String]) {
        foo(Impl[Int]())
    }
}
\end{minted}

С точки зрения языка Scala такой код корректный. Он проходит проверку типов и компиляцию, но во время выполнения происходит искючительная ситуация. Причиной этому является не совпадение сигнатур методов. Во время генерации класса Impl тип T становится наиболее общим типом Object. В то же время для вызова в методе foo сгенерировался метод ищущий функции с типом Int. Поэтому в во время выполнения нужная функция в объекте Impl отсутствует и происходит исключение.

\subsubsection{Whiteoak}
Whiteoak - это модификация языка Java с целью добавить поддержку структурных типов. Whiteoak модифицирует компилятор Java: добавляет новую синтаксическую конструкцию и её поведение в байткоде. Для обеспечения функциональности происходит генерация класса обёртки для каждого протокола. Каждый объект заворачивается в такую обёртку. Обёртка содержит в себе вызовы, которые перенаправляют вызов реальному объекту. Так как тип объекта для вызова не извесен во время компиляции, Whiteoak генерирует класс обёртку во время выполнения, для конкретного типа.

Преимущество данного подхода - высокая скорость работы. После генерации класса обёртки, скорость вызова метода протокола сводится к двум выполнениям инструкции invokevirtual, что практически не отличимо от обычного вызова метода.

Существенным недостатком данного подхода является потеря идентичности объекта при оборачивании. Дело в том что один и тот же объект, дважды приведённый к типу протокола, имеет разные обёртки, а следовательно и разные ссылки. В Whiteoak проблема решена следующим образом: везде где пользователь использует объект как сущность, используется ссылка на реальный объект. Это вносит определённые ограничения на использование протоколов в типовых параметрах. Появляется неоднозначность, какой объект ожидает метод: обёртку или ссылку. Эта проблема не решается в момент выполнения, поэтому Whiteoak запрещает использование параметрических типов для протоколов.

\section{Реализация}
В данном разделе рассмотрены и обоснованы выбранные решения, приведены сравнения производительности и выразительности языков.

\subsection{Прототип}
\subsection{Производительность}
%\subsubsection{Случай одного ресивера}
%\subsubsection{Случай нескольких ресиверов}

% У заключения нет номера главы
\section*{Заключение}

\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}