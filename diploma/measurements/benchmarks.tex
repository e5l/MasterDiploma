\subsection{Рассмотренные тесты}
В ходе тестирования работы протоколов было написано множество тестов производительности. В данном разделе приведены тесты интересные с точки зрения сравнения реализации протоколов в \lang{Kotlin} с другими реализациями, а так же тесты, демонстрирующие типичные сценарии использования протоколов в реальном окружении.

\subsubsection{Сравнение времени работы методов с различным числом аргументов}
Одной из особенностей прототипа была возможность создания только одного метода с одним аргументом. После реализации полноценной поддержки протоколов, была выявлена зависимость времени вызова метода от числа аргументов. В случаях использования библиотеки вызовов, с ростом числа аргументов, время работы было значительно ниже чем с использованием библиотекой рефлексии. На рисунке \ref{plot:bench:argsCount} приведено сравнение реализаций с помощью библиотеки вызовов и рефлексии с использованием целевых объектов одного типа. В качестве кеша поиска использовалась хеш-таблица неограниченного размера.

\begin{figure}[H]
\caption{\label{plot:bench:argsCount}Зависимость времени вызова от количества аргументов функции.}
\begin{tikzpicture}
\begin{axis}[
 legend pos = north west,
 legend cell align = left,
 %height = 0.6\paperheight,
  width = 0.75\paperwidth,
  xlabel = Количество аргументов,
  ylabel = Время работы (нс)
]
\legend{
  Kotlin - Библиотека вызовов,
  Kotlin - Библиотека рефлексии,
  Scala
};
\addplot coordinates {
  (0, 8.263) (1, 8.378) (2, 8.613) (3, 8.538) (4, 8.86) (5, 8.76) (10, 9.624) (15, 10.393) (20, 11.237)
};
\addplot coordinates {
  (0, 9.394) (1, 11.64) (2, 12.612) (3, 14.06) (4, 24.487) (5, 29.844) (10, 54.528) (15, 79.591) (20, 110.899)
};

\addplot coordinates {
  (0, 8.453) (1, 10.392) (2, 10.952) (3, 12.838) (4, 27.169) (5, 28.665) (10, 48.425) (15, 77.437) (20, 117.241)
};

\end{axis}
\end{tikzpicture}
\end{figure}

Данное поведение объясняется способом работы с аргументами у различных библиотек. В библиотеке рефлексии аргументы передаются в массиве, как набор ссылок типа \term{Object}. При каждом вызове необходимо проверить, подходит ли тип приведённого аргумента к типу вызова. Более того, необходимо время на выделение и заполнение массива аргументов на стеке.

В случае библиотеки вызовов проверка типов произошла во время поиска, поэтому дополнительные время работы слабо зависит от количества аргументов.

Подробное сравнение реализаций приведено в приложении 1.

\subsubsection{Сравнение времени работы вызова метода с различным числом целевых объектов}
Одной из проблем при использовании протоколов является выбор размера кеша. С фиксированным размером кеша, большое количество типов в одном месте вызова метода протокола может значительно повлиять на  производительность. С другой стороны чем больше размер кеша, тем дольше осуществляется поиск в нём.

Для сравнения производительности протоколов с различным размером кеша и разным количеством целевых объектов был написан тест в котором на списке из фиксированного числа объектов типа протокола вызывается один метод. В списке содержаться объекты типа протокола различных типов с точки зрения виртуальной машины. В каждом тесте был использован список фиксированной длины $10^5$, равномерно перемешанных элементов. На каждом объекте вызывался метод без аргументов. Результаты измерений приведены на рисунке \ref{plot:bench:targetCount}.

\begin{figure}[H]
\caption{\label{plot:bench:targetCount}Зависимость времени вызова от количества целевых объектов.}
\begin{tikzpicture}
\begin{axis}[
 legend pos = north west,
 legend cell align = left,
  height = 0.6\paperheight,
  width = 0.75\paperwidth,
  xlabel = Количество типов целевых объектов в коллекции,
  ylabel = Время работы (нс)
]
\legend{
  Размер кеша 1,
  Размер кеша 5,
  Размер кеша 10,
  Размер кеша 15,
  Размер кеша 20
};
\addplot coordinates {
  (1, 109502.258) (2, 3554346.414) (3, 4519802.625) (4, 5245621.98) (5, 5351651.687) (6, 5490078.168) (7, 5863253.316) (8, 6129173.583) (9, 6086508.887) (10, 5976393.915) (11, 6395793.802) (12, 6254356.672) (13, 6237242.247) (14, 6337879.8) (15,6388747.077) (16, 6524826.169) (17, 6612475.521) (18, 6469900.556) (19, 6518254.024) (20, 6805148.045)
};

\addplot coordinates {
  (1, 98341.46) (2, 198100.376) (3, 236357.516) (4, 260024.525) (5, 269373.949) (6, 1514416.958) (7, 2194493.478) (8, 2775916.83) (9, 3252827.393) (10, 3735306.59) (11, 3853191.272) (12, 4098807.046) (13, 4264129.326) (14, 4506557.185) (15, 4546119.439)(16, 4814566.299) (17, 4822778.364) (18, 5071961.412) (19, 4996804.396) (20, 5103139.354)
};

\addplot coordinates {
  (1, 99092.636) (2, 178022.589) (3, 238702.199) (4, 279654.546) (5, 288499.883) (6, 293045.105) (7, 301633.566) (8, 311196.548) (9, 340292.593) (10, 343882.499) (11, 1126985.107) (12, 1715599.885) (13, 2079864.232) (14, 2408478.146) (15, 2848241.272) (16, 2935226.312) (17, 3256539.55) (18, 3692752.764) (19, 3703143.588) (20, 3835244.516)
};

\addplot coordinates {
  (1, 96714.809) (2, 202200.597) (3, 253809.7) (4, 303802.301) (5, 272303.277) (6, 338691.183) (7, 351170.951) (8, 320262.113) (9, 395905.133) (10, 398198.951) (11, 366461.044) (12, 411515.694) (13, 379108.642) (14, 425054.543) (15, 407024.387) (16, 996247.884) (17, 1417862.467) (18, 1715993.026) (19, 2019544.803) (20, 2282171.577)
};

\addplot coordinates {
  (1, 99032.866) (2, 168301.161) (3, 236453.859) (4, 274001.602) (5, 280840.152) (6, 328606.601) (7, 367240.438) (8, 336811.459) (9, 389506.062) (10, 393525.132) (11, 444605.024) (12, 432010.685) (13, 414885.666) (14, 455137.636) (15, 471416.321) (16,456520.714) (17, 476866.07) (18, 476349.784) (19, 484654.281) (20, 500384.44)
};

\end{axis}
\end{tikzpicture}
\end{figure}

Из измерения видно что до тех пор пока размер кеша меньше чем количество типов посетивших место вызова, время вызова является небольшой константной. В то же время если число типов привышает размер кеша, время работы существенно возрастает. Исходя из этого можно дать рекомендацию к настройке компиляции: размер кеша должен быть как минимум количество типов, приводимых к протоколу.

Подробные результаты измерений приведены в приложении 2.

\subsubsection{Сравнение реализаций в различных языках}
Для сравнения полученной реализации с другими языками необходим тест, который будет отражать случаи реального использования протоколов в программах. Одним из таких случаев использования служит объявление интерфейса \term{Comarable} протоколом. Использование протокола \term{Comparable} позволят использовать любые объекты, обладающие оператором сравнения, без явного наследования.

На основе данного теста был написан тест сортирующий числа с помощью сортировки слиянием\cite{9780262033848}. В качестве сравниваемых объектов выступают объекты типа протокола, содержащего оператор сравнения. В качестве реализации были выбраны \tool{JVM} языки использующие схожий подход к реализации: \lang{Scala}, \lang{Kotlin}. Для компиляции \lang{Kotlin} используется реализация с использованием библиотеки вызовов и хеш-таблицей в качестве кеша. Результаты измерений приведены на рисунке \ref{plot:bench:mergeSort}.

\begin{figure}[H]
\caption{\label{plot:bench:mergeSort} Сортировка слиянием}
\begin{tikzpicture}
\begin{axis}[
  xmode = log,
  legend pos = north west,
  legend cell align = left,
  width = 0.75\paperwidth,
  xlabel = размер входа,
  ylabel = Время работы (мкс)
]
\legend{
  Kotlin,
  Scala
};

\addplot coordinates {
  (10, 0.599) (50, 4.612) (100, 9.868) (500, 61.271) (1000, 127.616) (5000, 738.57) (10000, 1497.701)
};

\addplot coordinates {
  (10, 0.516) (50, 3.819) (100, 10.086) (500, 57.09) (1000, 130.902) (5000, 769.18) (10000, 1700.018)
};

\end{axis}
\end{tikzpicture}
\end{figure}

Исходя из графика видно, что вызов функции с одним аргументом на протоколе работает примерно одно время, разница становится заметной при росте числа вызовов. Подробное сравнение реализаций приведено в приложении 3.
