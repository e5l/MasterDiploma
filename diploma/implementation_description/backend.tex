
\subsection{Прототип}
Вариант в котором структурный тип оборачивается в класс обёртку не подходит. При таком подходе теряется равеноство ссылок между исходным объектом и обёрнутым. Поэтому необходимо рассматривать подходы, при которых используются исходные ссылки на объект.

Переформулируя получаем что для реализации структурных типов необходимо уметь производить поиск и вызов любой функции на произвольном объекте. Такой функциональности можно добиться используя одну из двух стандартных библеотек: библиотеку рефлексии или библиотеку invoke. Поскольку обе библиотеки предоставляют схожую функциональность, выбор между ними сводится к поиску более производительного решения. Для того чтоб выбрать между ними реализован прототип, который осуществляет генерацию байткода для двух подоходов.

\subsubsection{Реализация с помощью рефлексии}
Для каждого места вызова генерируется статический метод. Этот метод принимает на вход объект на котором происходит вызов и возращает экземпляр класса Method. После этого все аргументы упаковываются в массив и вызывается метод invoke, который делает вызов нужного метода и сохраняет на стек результат. Поскольку сигнатура метода invoke не типизирована, то необходимо выполнить приведение типов.

\subsubsection{Реализация с помощью invokedynamic}
Рассмотрим реализацию с помощью invokedynamic. Аналогично предыдущему варианту, для каждого места вызова генерируется статический метод. В этом вызове происходит вызов инструкции invokedynamic, которой передаётся ссылка на вспомогательный статический метод и тип вызываемого метода. Помимо этого JVM передаёт экземпляр класса Lookup для данного места вызова. Внутри вспомогательного метода создаётся объект типа ConstantCallSite который содержит в себе вспомогательный класс, содержащий методы отвечающие за поиск нужного метода. Для поиска метода происходит вызов метода find для объекта, который возвращает экземпляр класса MethodHandle, ссылающийся на необходимый метод. Из вызова статического метода возвращается MethodHandle, вызов у него invokeExact вызывает необходимый метод. В отличии от механизма рефлексии, оборачивание аргументов в массив не требуется.

\subsubsection{Сравнение производительности}
Для реализации было предположено что типов, на которых делается вызов(в одном месте вызова), будет существенно меньше чем самих вызовов. Поиск метода выполняется не на самом объекте, а на его типе. Поэтому для каждого типа, на котором происходит вызов, храним найденный метод. Это позволит сильно сохранить время вызова.

\paragraph{Условия тестирования}
Тестирование проводилось на следующей конфигурации компьютера:
\begin{itemize}
    \item CPU Intel i7 6700 3.4 Ghz
    \item RAM 32GB DDR4
    \item Oracle JDK 1.8
    \item OS Ubuntu desktop 17.04 x64
    \item JMH 1.16
\end{itemize}

Цель данного измерения понять скорость вызова метода с помощью двух решений в различных случаях. Тестирование производилось для функции с одним аргументов, для одного типа на один тест. Вызовы производились в одном потоке. Внутри которой вызывается специальный метод JMH предотвращающий удаление непродуктивного кода. В процессе тестирования было обнаружено, что существует влияние типа реализации протокола на скорость вызова. Время выполнения измерялось в наносекундах на вызов, каждый бенчмарк запускался в течении секунды, результаты были усреднены по 20 запускам. Результаты измерений для рефлексии приведены в таблице \ref{benchmark:prototype:reflection}.
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|} \hline
Название бенчмарка & Время работы (нс) \\ \hline
Вызов метода класса & 4.815 $\pm$ 0.072 \\ \hline
Вызов метода наследника через ссылку на базовый класс & 4.797 $\pm$ 0.023 \\ \hline
Вызов метода интерфейса & 4.818 $\pm$ 0.055 \\ \hline
Вызов метода интерфейса реализованного анонимной функцией & 153.892 $\pm$ 0.909 \\ \hline
\end{tabular}
\caption{Результаты бенчмарка для реализации с помощью рефлексии}
\label{benchmark:prototype:reflection}
\end{center}
\end{table}

Из измерений видно что вызов метода реализованного анонимной функцией в 30 раз медленнее вызова обычного метода. Аналогичные измерения для библиотеки invoke приведены в таблице \ref{benchmark:prototype:invoke}.

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|} \hline
Название бенчмарка & Время работы (нс) \\ \hline
Вызов метода класса & 5.002 $\pm$ 0.031 \\ \hline
Вызов метода наследника через ссылку на базовый класс & 5.002 $\pm$ 0.037 \\ \hline
Вызов метода интерфейса & 5.016 $\pm$ 0.104 \\ \hline
Вызов метода интерфейса реализованного анонимной функцией & 5.069 $\pm$ 0.111 \\ \hline
\end{tabular}
\caption{Результаты бенчмарка для реализации с помощью библиотеки invoke}
\label{benchmark:prototype:invoke}
\end{center}
\end{table}

В реализации с помощью invoke все случаи использования работают с одной скоростью не зависимо от целевого объекта. В двух реализациях скорость является схожей, поэтому для дальнейшего изучения было принято решение реализовать оба способа в компиляторе и провести дальнейшие тестирования.
