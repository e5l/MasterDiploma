\subsection{Виртуальная машина Java}
% [https://en.wikipedia.org/wiki/Java_virtual_machine]
% [http://dmoztools.net/Computers/Programming/Languages/Java/Implementations/]
В данном разделе рассматриваются особенности разработки комилятора для виртуальной машины Java(далее JVM). JVM - абстрактная виртуальная машина и набор библиотек. Существует много различных реализаций JVM для разных платформ: HotSpot, IcedTea, Viva, Azul и т.д. Все реализации полностью или частично придерживаются спецификации JVM. В ней описаны набор инструкций и их ожидаемое поведение, модель памяти, формат исполняемых файлов и т.п. JVM является стековой машиной: операнды методов и результат вызовов распологаются на стеке.
% ссылка на спеку

JVM поддерживает раздельную компиляцию. Единицей компиляции является классфайл. В классфайле находится тип, с указанием родительского класса, информация о родительских интерфейсах, поля и методы. Код метода содержит последовательность инструкций виртуальной машины. Классфайлы собираются в архивы формата jar.

\subsubsection{Байткод виртуальной машины}
Исходный код метода состоит из последовательность однобайтовых(иногда двухбайтовых) инструкций. Присутствуют инструкции для работы с локальными переменными, создания объектов и примитивных типов, арифметические операции, инструкции для вызова метода, условные переходы. Отсутствуют инструкции для прямой работы с памятью: нельзя взять указатель на определённый адрес или перейти к исполнению адреса. Объекты передаются по ссылкам.

Все инструкции строго типизированы. Есть два вида типов: примитивные типы передающиеся по значению и ссылочные типы. Примитивные типы заранее определены в JVM, пользовательские примитивные типы создать нельзя. Для каждого примитивного типа существует парный ссылочный тип, который используется в особых случаях. Существуют следующие типы примитивных типов: int, boolean, short. Парные ссылочные типы: Integer, Boolean, Short соответственно. В языке Kotlin такое разделение отсутствует. Программист пользуется встроенным типом, какой тип использовать решает компилятор.

В JVM встроен механизм исключений. В любом месте кода может быть написана инструкция, обозначающая исключительную ситуацию. При выполнении такой инструкции исполнение будет передано ближайшему блоку обработки исключений подходящего типа.

Большинство методов в JVM виртуальные, так же поддерживаются статические методы.
На уровне JVM поддерживается номинальная система типов и отношение наследования. По умолчанию каждый класс наследуется от класса Object. Для вызова метода необходимо знать тип объекта, в котором находится поле, имя метода и его сигнатуру. Для вызова методов используются invoke-инструкции. Существует несколько разных invoke-инструкций:
\begin{itemize}
    \item \textbf{invokespecial} используется для вызова конструкторов у не инициализированных объектов
    \item \textbf{invokevirtual} используется для вызова методов у класса,
    \item \textbf{invokestatic} используется для вызова статических методов
    \item \textbf{invokedynamic} используется для вызова различных методов, при этом механизм выбора метода определяется специальной функцией, которая передаётся в аргументах
\end{itemize}
Перед загрузкой класса виртуальная машина запустит верификатор, который проверит наличие методов и соответствие типов аргументов. Невозможно напрямую вызвать метод, если неизвесен реальный тип объекта.

\textbf{Рефлексия}

Существует способ узнавать содержимое классов и вызывать произвольные методы во время выполнения с помощью рефлексии. Во время выполнения из JVM можно получить информацию о том, какие методы присутствуют в конкретном объекте и их сигнатуру. По имени и точной сигнатуре получить ссылку на метод и по ней сделать вызов. Вызов происходит с помощью метода invoke класса Method. Данный метод принимает объект на котором происходит вызов(далее ресивер) и массив с аргументами. Поиск метода может занимать длительное время. Вызов метода происходит дольше чем вызов с помощью invokevirtual поскольку при каждом вызове происходит заворачивание аргументов в массив и проверка типов. Если при вызове метода происходит исключительная ситуация, то метод порождает исключение типа InvocationTargetException причиной которого является исходное исключение.

% invokedynamic: boostrap method, lookup object, method handle
% рассказать про то что exception оборачивается
\textbf{Инструкция invokedynamic}
% JSR, MethodHandle
Рассмотрим подробнее инструкцию invokedynamic. Эта инструкция принимает на вход ссылку на специальный статический метод. Этот метод определяется разработчиком и вызывается только при первой интерпретации инструкции. Результат вызова этого метода сохраняется внутри виртуальной машины и не вычисляется при следующем обращении. Метод имеет специальную сигнатуру: ему передаётся специальный словарь, к которому можно сделать запрос на наличие определённого метода или поля у объекта. Таким образом можно получить функциональность схожую с рефлексией, но выполняющую поиск метода и проверку типов только один раз.