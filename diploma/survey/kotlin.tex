\subsection{Язык Kotlin}

Целевой платфомой языка \lang{Kotlin} является \tool{JVM}. \lang{Kotlin} поддерживает совместимость с языком \lang{Java} \cite{kotlin:compatibility}, поддерживается раздельная компиляция. Несмотря на это, существуют большие различия.

Для абстрактных методов в интерфейсах и класах в \lang{Kotlin} можно задавать реализацию по умолчанию. Для методов присутствует перегрузка по параметрам. Аргументы могут иметь значения по умолчанию.

\subsubsection{Типизация}
В \lang{Kotlin} присутствует проверка пустоты ссылок на уровне системы типов. В обычные ссылки невозможно положить пустую. Для работы с пустыми ссылками существует специальный синтаксис.

В \lang{Kotlin} присутствует собственный набор встроенных типов: \term{Int}, \term{Short}, \term{Boolean}, и т.д. Для объявления типов, в которых можно хранить пустую ссылку, в конце добавляется вопросительный знак: \term{Int?}, \term{Short?}, \term{Boolean?}. Благодаря тому, что типы проаннотированы, в процессе компиляции \lang{Kotlin} проверяет корректность присваивания на уровне типов. Во время трансляции встроенный тип может стать как примитивным, так и ссылочным, в зависимости от контекста использования и возможности хранения пустой ссылки. Например в большинстве случаев \term{Int?} будет оттранслирован в \term{Integer}, а \term{Int} в \term{int}.

\lang{Kotlin} использует номинальную систему типов с наследованием. Поддерживается механизм интерфейсов. В языке присутствуют операторы \operator{is} и \operator{as}. С помощью первого, во время выполнения можно проверить является ли объект экземпляром указанного типа. Второй оператор пытается выполнить приведение типов.

В \lang{Kotlin} существует возможность создавать интерфейсы. В интерфейсах можно задать реализацию методов по умолчанию.

\paragraph{Параметрические типы}
В \lang{Kotlin} существует возможность создавать параметрические типы. Тип параметра указывается в треугольных скобках. На параметрических типах можно задавать отношение порядка, в зависимости от типа параметра. Это можно сделать как и в объявлении типа, так и при определении шаблонного метода.
