\subsection{Прототип}

Детальнее рассмотрим требования, которые должна соблюдать реализация.

\begin{itemize}
\item Язык Kotlin совместим с Java. Это значит, что объекты из языка Kotlin должны быть корректными объектами для языка Java и в обратную сторону. Одной из важных особенностей, которую хочется сохранить - это идентичность объекта, то есть приведение к структурному типу должно не модифицировать ссылку на объект.
\item Другим важным требованием является возможность использования структурных типов как в качестве типов коллекций, так и в качестве элементов существующих коллекций. Таким образом необходимо, чтоб структурные типы поддерживали типовые параметры.
\item Протоколы не должны вносить ощутимых расходов на потребление памяти и время работы при приведении типов и вызове метода.
\item Возможности использование структурных типов должны быть схожи с обычными типами.
\item По возможности необходимо избегать генерации кода в процессе выполнения
\end{itemize}

Вариант в котором структурный тип оборачивается в класс обёртку не подходит. При таком подходе теряется равеноство ссылок между исходным объектом и обёрнутым. Поэтому необходимо рассматривать подходы, при которых используются исходные ссылки на объект.

Переформулируя получаем что для реализации структурных типов необходимо уметь производить поиск и вызов любой функции на произвольном объекте. Такой функциональности можно добиться используя одну из двух стандартных библеотек: библиотеку рефлексии или библиотеку invoke. Поскольку обе библиотеки предоставляют схожую функциональность, выбор между ними сводится к поиску более производительного решения. Для того чтоб выбрать между ними реализован прототип, который осуществляет генерацию байткода для двух подоходов.

\subsubsection{Реализация с помощью рефлексии}
Для каждого места вызова генерируется статический метод. Этот метод принимает на вход объект на котором происходит вызов и возращает экземпляр класса Method. После этого все аргументы упаковываются в массив и вызывается метод invoke, который делает вызов нужного метода и сохраняет на стек результат. Поскольку сигнатура метода invoke не типизирована, то необходимо выполнить приведение типов.

\subsubsection{Реализация с помощью invokedynamic}
Рассмотрим реализацию с помощью invokedynamic. Аналогично предыдущему варианту, для каждого места вызова генерируется статический метод. В этом вызове происходит вызов инструкции invokedynamic, которой передаётся ссылка на вспомогательный статический метод и тип вызываемого метода. Помимо этого JVM передаёт экземпляр класса Lookup для данного места вызова. Внутри вспомогательного метода создаётся объект типа ConstantCallSite который содержит в себе вспомогательный класс, содержащий методы отвечающие за поиск нужного метода. Для поиска метода происходит вызов метода find для объекта, который возвращает экземпляр класса MethodHandle, ссылающийся на необходимый метод. Из вызова статического метода возвращается MethodHandle, вызов у него invokeExact вызывает необходимый метод. В отличии от механизма рефлексии, оборачивание аргументов в массив не требуется.

\subsubsection{Сравнение производительности}
Для реализации было предположено что типов, на которых делается вызов(в одном месте вызова), будет существенно меньше чем самих вызовов. Поиск метода выполняется не на самом объекте, а на его типе. Поэтому для каждого типа, на котором происходит вызов, храним найденный метод. Это позволит сильно сохранить время вызова.

\paragraph{Условия тестирования}
Тестирование проводилось на следующей конфигурации компьютера:
\begin{itemize}
    \item CPU Intel i7 6700 3.4 Ghz
    \item RAM 32GB DDR4
    \item Oracle JDK 1.8
    \item OS Ubuntu desktop 17.04 x64
    \item JMH 1.16
\end{itemize}

Цель данного измерения понять скорость вызова метода с помощью двух решений в различных случаях. Тестирование производилось для функции с одним аргументов, для одного типа на один тест. Вызовы производились в одном потоке. Внутри которой вызывается специальный метод JMH предотвращающий удаление непродуктивного кода. В процессе тестирования было обнаружено, что существует влияние типа реализации протокола на скорость вызова. Время выполнения измерялось в наносекундах на вызов, каждый бенчмарк запускался в течении секунды, результаты были усреднены по 20 запускам.

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|} \hline
$p$ Название бенчмарка & Время работы (нс) \\ \hline
Вызов метода класса с помощью рефлексии & 2.400 $\pm$ 0.048\\ \hline
\end{tabular}
\caption{Результаты бенчмарка для реализации с помощью рефлексии}
\label{benchmark:prototype:reflection}
\end{center}
\end{table}
