\documentclass{spbau-diploma}
\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра математических и информационных технологий},
    title              = {Протоколы/Структурные типы в Kotlin},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {master},
    position           = {студента},
    group              = SE,
    author             = {Сташевский Леонид Евгеньевич},
    supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Жарков Д.\,Буква.},
    reviewerPosition   = {ст. преп.},
    reviewer           = {Привалов А.\,И.},
    chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
    chairHead          = {Омельченко А.\,В.},
    % university = {САНКТ-ПЕТЕРБУРГСКИЙ АКАДЕМИЧЕСКИЙ УНИВЕРСИТЕТ},
    % faculty = {Центр высшего образования},
    % city = {Санкт-Петербург},
    % year             = {2013}
}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}
В современных языках программирования существует много способов вводить отношение подтипизации. Самый популярный подход - это отношение наследования или номинальная типизация. В наследовании программист сам решает какой объект является наследником другого. На языке типов это означает что тип наследника является подтипом типа предка. Существует вариант автоматического вывода отношения подтипизации на основе интерфейса объектов. В процессе сборки, компилятор проверяет что используемый тип удовлетворяет ограничениям указанного типа. Такая система типов называется структурной. Такая типизация встречается в некоторых языках программирования: Go, семейство ML.

Номинальная типизация является простой, а следовательно и более распространённой. Она используется в таких языках как Java, C++, Kotlin. Вместе с простотой на программиста накладываются ограничения: при взаимодействии с кодом, который уже скомпилирован в библиотеку. Типы находящиеся в других модулях нельзя добавить в иерархию наследования, поэтому для них приходится писать и поддерживать типы-обёртки.

Существует другое решение, сохраняющее простоту и выразительность. Можно использовать номинальную типизацию в большинстве случаев, а там где необходима гибкость - использовать структурный тип. Такой подход сохранит совместимость с уже написанным кодом и позволит писать более выразительный код. В языке с номинальными типами структурные типы называют протоколами.

На данный момент набирает популярность язык Kotlin. В нём используется номинальная система типов. На момент написания его основной целевой платформой является виртуальная машина языка Java. Существуют несколько языков на основе JVM, в которых поддерживаются структурные типы. Например они поддерживаются языками Scala, Whiteoak.

\section*{Постановка задачи}
Цель данной работы - реализация поддержки протоколов в языке Kotlin. Для её достижения необходимо выполнить следующие задачи:
\begin{itemize}
    \item Исследование способов реализации структурных типов в JVM, существующие реализации и выяснение ограничений
    \item Реализация и тестирование прототипа
    \item Реализация проверки типов в компиляторе языка Kotlin
    \item Генерация кода для компилятора
    \item Поддержка раздельной компиляции
    \item Поддержка многопоточности
    \item Измерение производительности и оптимизация
\end{itemize}

\section{Обзор предметной области}
% структурная типизация и механизм проверки типов, приводится сравнение существующих реализаций протоколов в других языках программирования.
\subsection{Виртуальная машина Java}
% [https://en.wikipedia.org/wiki/Java_virtual_machine]
% [http://dmoztools.net/Computers/Programming/Languages/Java/Implementations/]
В данном разделе рассматриваются особенности разработки комилятора для виртуальной машины Java(далее JVM). JVM - абстрактная виртуальная машина и набор библиотек. Существует много различных реализаций JVM для разных платформ: HotSpot, IcedTea, Viva, Azul и т.д. Все реализации полностью или частично придерживаются спецификации JVM. В ней описаны набор инструкций и их ожидаемое поведение, модель памяти, формат исполняемых файлов и т.п. JVM является стековой машиной: операнды методов и результат вызовов распологаются на стеке.
% ссылка на спеку

JVM поддерживает раздельную компиляцию. Единицей компиляции является классфайл. В классфайле находится тип, с указанием родительского класса, информация о родительских интерфейсах, поля и методы. Код метода содержит последовательность инструкций виртуальной машины. Классфайлы собираются в архивы формата jar.

\subsubsection{Байткод виртуальной машины}
Исходный код метода состоит из последовательность однобайтовых(иногда двухбайтовых) инструкций. Присутствуют инструкции для работы с локальными переменными, создания объектов и примитивных типов, арифметические операции, инструкции для вызова метода, условные переходы. Отсутствуют инструкции для прямой работы с памятью: нельзя взять указатель на определённый адрес или перейти к исполнению адреса. Аллоцированные объекты передаются по ссылкам.

Все инструкции строго типизированы. Есть два вида типов: примитивные типы передающиеся по значению и ссылочные типы. Примитивные типы заранее определены в JVM, пользовательские примитивные типы создать нельзя. Для каждого примитивного типа существует парный ссылочный тип, который используется в особых случаях. Существуют следующие типы примитивных типов: int, boolean, short. Парные ссылочные типы: Integer, Boolean, Short соответственно. В языке Kotlin такое разделение отсутствует. Программист пользуется встроенным типом, какой тип использовать решает компилятор.

На уровне JVM поддерживается номинальная система типов и отношение наследования. Для вызова метода необходимо знать тип объекта, в котором находится поле, имя метода и его сигнатуру. Для вызова методов используются invoke-инструкции. Существует несколько разных invoke-инструкций:
\begin{itemize}
    \item \textbf{invokespecial} используется для вызова конструкторов у непроинициализированных объектов
    \item \textbf{invokevirtual} используется для вызова методов у класса
    \item \textbf{invokestatic} используется для вызова статических методов
    \item \textbf{invokedynamic} используется для вызова различных методов, при этом механизм выбора метода определяется специальной функцией, которая передаётся в аргументах
\end{itemize}
Перед загрузкой класса виртуальная машина запустит верификатор, который проверит наличие методов и соответствие типов аргументов. Невозможно напрямую вызвать метод, если неизвесен реальный тип объекта.

\textbf{Рефлексия}

Существует способ узнавать содержимое классов и вызывать произвольные методы во время выполнения с помощью рефлексии. Во время выполнения из JVM можно получить информацию о том, какие методы присутствуют в конкретном объекте и их сигнатуру. По имени и точной сигнатуре получить ссылку на метод и по ней сделать вызов. Вызов происходит с помощью метода invoke класса Method. Данный метод принимает объект на котором происходит вызов(далее ресивер) и массив с аргументами. Поиск метода может занимать длительное время. Вызов метода происходит дольше чем вызов с помощью invokevirtual поскольку при каждом вызове происходит заворачивание аргументов в массив и проверка типов.

% invokedynamic: boostrap method, lookup object, method handle
\textbf{Инструкция invokedynamic}

Рассмотрим подробнее инструкцию invokedynamic. Эта инструкция принимает на вход ссылку на специальный статический метод. Этот метод определяется разработчиком и вызывается только при первой интерпретации инструкции. Результат вызова этого метода сохраняется внутри виртуальной машины и не вычисляется при следующем обращении. Метод имеет специальную сигнатуру: ему передаётся специальный словарь, к которому можно сделать запрос на наличие определённого метода или поля у объекта. Таким образом можно получить функциональность схожую с рефлексией, но выполняющую поиск метода и проверку типов только один раз.

\subsection{Структурная типизация}
В данном разделе рассмотрены основы структурной типизации и алгоритм для проверки типов.

\subsection{Обзор существующих решений}
\subsubsection{Scala}
\subsubsection{Whiteoak}
\subsubsection{Go}

\section{Реализация}
\subsection{Прототип}
\subsection{Производительность}
%\subsubsection{Случай одного ресивера}
%\subsubsection{Случай нескольких ресиверов}

\section{План}

\begin{itemize}
    \item введение в типизацию
    \item постановка задачи: структурная типизация
    \item почему и кому это нужно: примеры использования, востребованность в других языках
    \item обзор реализаций и статей: scala, whiteoak, go. посмотреть принятые решения там
    \item Реализация: бэкэнд, фронтенд
    \item Фронтенд: рассказать какие случаи в языке допустимы для проверки типов, привести крайние случаи и примеры
    \item Бэкэнд: варианты реализации возможные, что используется в других языках на бэкэнде. Выбор между гибкостью и скоростью. Прототип и тесты производительности. В каких местах и что быстрей. Кэширование: как в других языках, в чём смысл. Сколько в процентном соотношении занимает разрешение ссылки на метод.
    \item Имплементация которая выбрана и реализована(или несколько). (?Детали реализации в компиляторе? какие? стоит ли?)
    \item Табличка с результатами сравнения
    \item Заключение
\end{itemize}


% У заключения нет номера главы
\section*{Заключение}

\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}
