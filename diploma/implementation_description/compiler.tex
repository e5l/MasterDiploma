\subsection{Реализация протоколов в компиляторе Kotlin}
В данном разделе будет рассказано о деталях реализации протоколов в компиляторе Kotlin. Сперва рассмотрена основная функциональность реализации, рассказано как решены проблемы встреченные в других реализациях. Затем будет рассказано про структуру и особенность реализации функциональности в самом компиляторе и стандартной библиотеке.

Для поддержки протоколов в компиляторе был введён новый тип интерфейсов и добавлено ключевое слово protocol со следующим синтаксисом:

\begin{minted}
[frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos]
{kotlin}
protocol interface Proto {
  fun id(i: Int): Int
}

class Impl {
  fun id(i: Int): Int {
    return i
  }
}

fun foo(arg: Proto) {
  println(arg.id(42))
}

foo(Impl())
\end{minted}

% Таким образом протоколы объявляются как самостоятельный тип.

\subsubsection{Исключения}
\subsubsection{Примитивные типы}
\subsubsection{Типовые параметры}

\paragraph{Наследование и наличие типа}
Ещё одной из проблем при полном стирании типа является невозможность наследования: при наследовании необходимо написать тип родителя. Данную проблему можно решить частичным стиранием типа: тип интерфейса генерируется и используется для наследования, во всех остальных случаях тип стирается.

\paragraph{Операторы проверки и приведения типа}
Для обычных типов в Kotlin разрешено приведение или проверка любого объекта к любому типу. В большинстве случаев объекты реализующие протоколы не являются типами протоколов с точки зрения JVM. С такой данной точки зрения возможно два поведения: реальная проверка типов инструкцией JVM либо проверка соответствию протоколов во время выполнения. Оба способа возможно реализовать практически. С точки зрения пользователя каждое из поведений может являться не ожидаемым, поэтому было принято решение запретить использование протоколов в правой части операторов as и is. В тоже время разрешено присваивание объекта обычного типа к типу протокола если проверка ограничений на тип проходит во время компиляции.

Если извесен исходный тип объекта типа протокола, то можно выполнить приведение типов. Так же можно выполнить проверку типов на объекте типа протокола.

Таким образом существует возможность перехода от обычных типов к протоколам и от протоколов к обычным типам.

\paragraph{Типовые параметры}
Так как во время выполнения выполняется поиск перегрузок, ограничений на использование типовых параметров нет. Протоколы могут использовать типовые параметры точно так же как и обычные типы. Поддерживаются ковариантные и контрвариантные параметры и отношения на них.

\begin{minted}
[frame=lines,
framesep=2mm,
baselinestretch=1.2,
linenos]
{kotlin}
class A<in T>
class B<out T>
protocol interface X<T>
...
val x: X<Int> = A<Int>()
val y: X<Int> = B<Int>()
\end{minted}

%\paragraph{Разрешение перегрузок}
%Рассмотрим проблему несовпадения типов при использовании примитивных типов. Поиск методов выполняется по точному типу функции. Мы проверяем что необходимый метод существует во время компиляции. Проблема возникает в том что при трансляции конечные типы не совпадают. Данную проблему можно решить во время выполнения. Для этого необходимо изменить поиск метода из библиотеки на алгоритм разрешения перегрузок. Идея заключается в том, чтоб выбирать ближайшую по расстоянию функцию.
%
%Для выбора перегрузки, для каждого метода в классе с таким же именем считается вектор расстояния. Каждая компонента этого вектора - расстояние между типами аргументов в типе метода и типе сохранённом во время компиляции если они в одной иерархии наследования, в противном случаее -1. Из всех векторов выбирается тот, у которого все координаты не меньше чем у любого другого вектора. Наличие и единственность такого метода будут гарантированы во время компиляции при приведении типов.



% проверка типов - проверка возможности сделать оверрайд
% генерация интерфейса => анонимные имплементации
% райнтайм - выбор перегрузок
% кэш
