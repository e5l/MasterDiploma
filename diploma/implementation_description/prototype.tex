
\subsection{Постановка проблемы}

Рассмотрим обычную ситуацию использования протокола с точки зрения пользователя. Сущесвтует протокол, являющийся структурным типом. Существует уже заранее скомпилированный тип который содержит методы протокола(а значит и является его подтипом), но явное наследование не указывается. С точки зрения виртуальной машины привести существующий тип можно лишь к тому типу который содержится в его иерархии наследования. Протокол был создан независимо от подходящего типа, поэтому в иерархии наследования он отсутствует. Более того в месте вызова гипотетически может быть любой тип, удовлетворяющий требованиям протокола. Это значит что тип во время компиляции не известен и приведение типа к типу протокола невозможно. Следовательно невозможно сгенерировать вызов с помощью любой инструкции в момент компиляции.

Для решения данной проблемы существует два подхода. Первый подход заключается в генерации класса обёртки для каждого типа, который приводится к структурной и делегирует вызов объекту конкретного типа. В момент генерации класса обёртки должен быть извесен тип объекта который приводится к протоколу, а значит либа необходима информация о всех типах в момент компиляции, либо обёртки для примитивных типов прийдётся генерировать в момент первого приведения каждого типа. Таким образом необходимо либо генерировать новые классы во время выполнения, либо отказаться от раздельной компиляции. Более того возникает проблема определения идентичности объекта: дважды приведённый объект будет иметь разные экземпляры классов обёрток и проверка на идентичность не пройдёт.

Второй подход заключается в использовании библиотек, которые работают с информацией об объекте во время выполнения: библиотеки вызовов или библиотеки invoke. При таком подходе информацию о типах знать не нужно, её можно получить во время компиляции. Данный подход может работать медленнее, но не накладывает ограничений на разработку компилятора, поэтому он был выбран в качестве базового подхода.

\subsection{Прототип}
Для реализации структурных типов необходимо уметь производить поиск и вызов любой функции на произвольном объекте. Такой функциональности можно добиться используя одну из двух стандартных библиотек: библиотеку рефлексии или библиотеку вызовов. Поскольку в данном контексте обе библиотеки предоставляют схожую функциональность, выбор между ними сводится к поиску более производительного решения. Для того чтоб выбрать между ними реализован прототип, задачей которого является измерение производительности двух подходов. В качестве модели была выбрана ситуация вызова одного метода протокола с одним ссылочным аргументом возвращающая ссылочный аргумент. В прототипе осуществляется ручная генерация байткода для двух подоходов.

\subsubsection{Реализация с помощью библиотеки рефлексии}
Рассмотрим реализацию с помощью библиотеки рефлексии. Для места вызова метода протокола генерируется статический метод. Этот метод принимает на вход объект на котором происходит вызов и возращает экземпляр класса \method{Method}. После этого все аргументы упаковываются в массив и вызывается метод \method{invoke}, который делает вызов нужного метода и сохраняет на стек результат. Поскольку сигнатура метода \method{invoke} не типизирована, то необходимо выполнить приведение типов. Внутри статического метода делается обращение к классу на поиск метода с нужным именем и типом. При использовании протколов имеет место следующее предположение: типов, которые будут приведены к протколу в конкретном месте вызова будет значительно меньше чем самих вызовов метода. Тип и имя метода известны в момент компиляции и не меняются в процессе выполнения. Процедура поиска метода происходит значительно дольше чем вызов, поэтому для поиска метода выгодно использовать кеширование результата. Так как тип объекта на котором осуществляется вызов один, результат поиска сохраняется в статическое поле класса при первом вызове и используется как результат в дальнейшем.

\subsubsection{Реализация с помощью библиотеки вызовов}
  Рассмотрим реализацию с помощью библиотеки вызовов. Аналогично предыдущему варианту, для каждого места вызова генерируется статический метод. В этом вызове происходит вызов инструкции \method{invokedynamic}, которой передаётся ссылка на вспомогательный статический метод и тип вызываемого метода. Помимо этого \tool{JVM} передаёт экземпляр класса \method{Lookup} для данного места вызова. Внутри вспомогательного метода создаётся объект типа \method{ConstantCallSite} который содержит в себе вспомогательный класс, содержащий методы отвечающие за поиск нужного метода. Для поиска метода происходит вызов метода \method{find} для объекта, который возвращает экземпляр класса \method{MethodHandle}, ссылающийся на необходимый метод. Из вызова статического метода возвращается \method{MethodHandle}, вызов у него \method{invokeExact} вызывает необходимый метод. В отличии от механизма рефлексии, оборачивание аргументов в массив не требуется. Помимо \method{invokeExact} существует так же метод \method{invoke}, который в случае необходимости производит приведение типов.

\subsubsection{Сравнение производительности}
Цель данного измерения понять скорость вызова метода с помощью двух решений в различных случаях. В ходе различных тестирований была выявлена зависимость между типом реализации вызываемого объекта и временем работы, данный критерий был взят в качестве параметра тестирования. Для тестирования были выделены следующие типы целевых объектов: финальный метод класса, переопределённый метод наследника вызванный через ссылку на базовый класс, метод интерфейса реализовынный классом, метод интерфейса реализованный анонимной функцией. Тестирование производилось для функции с одним аргументов, для одного типа на один тест. Вызовы производились в одном потоке. Внутри которой вызывается специальный метод JMH предотвращающий удаление непродуктивного кода. В процессе тестирования было обнаружено, что существует влияние типа реализации протокола на скорость вызова. Время выполнения измерялось в наносекундах на вызов, каждый бенчмарк запускался в течении секунды, результаты были усреднены по 20 запускам. Результаты измерений для рефлексии приведены в таблице \ref{benchmark:prototype}.
\begin{table}{h}
\begin{center}
\begin{tabular}{|c|c|c|c|} \hline
Тип метода & Рефлексия(нс) &  Вызовы(нс) & Фактор \\ \hline
Класс & 4.815 $\pm$ 0.072 & 5.002 $\pm$ 0.031 & 0.963 \\ \hline
Наследник & 4.797 $\pm$ 0.023 & 5.002 $\pm$ 0.037 & 0.959 \\ \hline
Интерфейс & 4.818 $\pm$ 0.055 & 5.016 $\pm$ 0.104 & 0.961 \\ \hline
Анонимная функция & 153.892 $\pm$ 0.909 & 5.069 $\pm$ 0.111 & 30.359 \\ \hline
\end{tabular}
\caption{Результаты бенчмарка для реализации с помощью рефлексии}
\label{benchmark:prototype}
\end{center}
\end{table}

Из результатов измерения видно, что в среднем библиотека вызовов немного медленнее чем библиотека рефлексии. Однако существуют ситуации в которых библиотека рефлексии в 30 раз медленее. Для поиска причин замедления было принято решение изучить машинный инструкции, с целью найти причину замедления и по возможности устранить её. Для этого были сделаны снимки с помощью утилиты \tool{perfasm}, которая позволяет вывести горячие точки - байткод и машиннструкции выполнявшиеся дольше всего. Листинг горячих точек можно найти в приложении !ДОБАВИТЬ ПРИЛОЖЕНИЕ!. Изучение горячих точек показало что основное время выполнения происходит внутри исходного кода виртуальной машины в пределах одной инструкции вызова. Таким образом оптимизации с точки зрения байткода не представляются возможными.

После оценки результатов измерений было принято решение реализовать оба способа в компиляторе и предоставить пользователю возможность выбрать одну из реализаций с помощью опций компиляции. Обе библиотеки достаточно динамично развиваются, поэтому в будующем возможна оптимизация отдельных случаев использования в виртуальной машине.
