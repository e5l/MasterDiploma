\subsubsection{Язык Go}
Язык Go компилируется в бинарный код. Интерфейсы в Go являются структурными типами\cite{go}.

\begin{pyglist}[language=go]
type geometry interface {
    area() float64
    perim() float64
}

type rect struct {
    width, height float64
}

func (r rect) area() float64 {
    return r.width * r.height
}
func (r rect) perim() float64 {
    return 2*r.width + 2*r.height
}

func measure(g geometry) {
    fmt.Println(g)
    fmt.Println(g.area())
    fmt.Println(g.perim())
}

func main() {
    r := rect{width: 3, height: 4}
    measure(r)
}
\end{pyglist}

Рассмотрим реализацию структурных типов в компиляторе gccgo. Так как Go компилируется в бинарный код, разрешён вызов метода по указателю. Для каждого интерфейса компилируется специальный дескриптор типа. Каждый дескриптор содержит в себе список методов. Для каждого метода сохраняются: имя, сигнатура, указатель на реализацию. Объект содержит в себе ссылку на набор дескрипторов. По возможности разрешение метода происходит во время компиляции. В ситуациях когда ссылка на необходимые дескрипторы не получается разрешить во время компиляции, это происходит в во время выполнения при создании объекта.

Плюс подхода заключается в высокой скорости вызова и гибкости реализации для различных случаев использования. Такой подход не реализуем на JVM из-за отсутствия прямого доступа к памяти.