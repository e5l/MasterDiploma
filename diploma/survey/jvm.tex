\subsection{Виртуальная машина Java}
В данном разделе рассматриваются особенности разработки компилятора для виртуальной машины Java(далее JVM).

Виртуальная машина JVM - это часть JRE ответственная за исполнение программ. JVM представляет из себя абстрактную виртуальную машину, описанную спецификацией\cite{jvm:specification}. В спецификации описаны набор инструкций, модель памяти, формат исполняемых файлов, ожидаемое поведение. Это значит что существует много различных реализаций JVM для разных платформ: HotSpot, IcedTea, Viva, Azul и т.д.

На уровне JVM реализуется большинство языковых инструментов: классы и наследование, объявление статических полей и методов, набор примитивных типов, механизм исключений. Объявление свободных функций вне класса невозможно.

\subsection{Типизация}
В JVM используется строгая статическая номинальная типизация. Это значит что все инструкции строго типизированы и наследование поддерживается на уровне виртуальной машины.

Все типы делятся на 2 класса: примитивные и ссылочные. JVM определяет некоторое количество встроенных типов. Пользователи могут определять собственные типы.

Среди встроенных типов существует набор примитивных типов. Примитивные типы всегда передаются по значению. Это сделано из соображений производительности. Для встроенных примитивных типов существуют зеркальные ссылочные типы, для передачи по ссылке. Для таких типов существует встроенная конвертация из одного типа в другой. Существуют следующие типы примитивных типов: int, boolean, short; парные ссылочные типы: Integer, Boolean, Short соответственно. Объявить пользовательские примитивные типы невозможно.

\subsection{Исполнение кода}
Виртуальная машина Java придерживается объектно ориентированной парадигме. Единицей исполнения является классфайл. Все классы находятся в общей иерархии наследования: существует класс встроенный Object от которого по умолчанию наследуется каждый класс.

Классфайлы собираются в архивы формата jar. При необходимости загрузчик классов виртуальной машины производит загрузку классфайла, поэтому по ходу выполнения программы возможно появление новых классов.

\subsection{Видимость}



\subsubsection{Байткод виртуальной машины}
Рассмотрим подробно структуру классфайла. Каждый классфайл содержит в себе описание одного класса. В каждом классе хранится набор его полей, методов и информация о базовом классе. С каждым полем и методом хранится их тип. Исходный код метода состоит из последовательности однобайтовых(реже двухбайтовых) инструкций и секции локальных переменных.

Рассмотрим имеющийся набор инструкций. В байткоде присутствуют инструкции для работы с локальными переменными, для создания объектов и примитивных типов, арифметические операции, инструкции для вызова методов, условные переходы. Стоит отметить что полностью отсутствуют любые инструкции для прямого доступа к памяти: нельзя взять указатель на определённый адрес, перейти к исполнению адреса или прочитать адрес. Виртуальная машина полностью скрывает детали реализации аппаратной части в которой работает. В случае если переменная класса непроинициализирована объектом, в ней хранится пустая ссылка(null).

% На уровне JVM поддерживается номинальная система типов и отношение наследования. Для вызова метода необходимо знать тип объекта, в котором находится поле, имя метода и его сигнатуру. Для вызова методов используются инструкции семейства invoke. Существует несколько разных invoke-инструкций:

Помиомо описанного в JVM поддерживает модификаторы видимости. Их можно наложить на классы, поля и методы.  Сущесвтует четыре вида видимости: публичный, приватный, защищённый и пакетный. Публичный доступен всем, приватный доступен только в том же классе что и объект, защищённый доступен наследникам, пакетный на уровне пакета.
\begin{itemize}
    \item \textbf{invokespecial} используется для вызова конструкторов у не инициализированных объектов, обращения к приватным полям текущего объекта и обращение к полям базового класса
    \item \textbf{invokevirtual} используется для вызова методов у класса
    \item \textbf{invokestatic} используется для вызова статических методов
    \item \textbf{invokedynamic} инструкция добавленная для вызова функций в динамических языках, будет рассмотрена далее
\end{itemize}
Перед загрузкой класса виртуальная машина запустит верификатор, который проверит наличие методов и соответствие типов аргументов. Невозможно напрямую вызвать метод, если неизвестен реальный тип объекта.

Существует две стандартные библиотеки для вызова методов без информации о типе: библиотека рефлексии и библиотека invoke.
\paragraph{Рефлексия}
% проверить поле class
Существует способ узнавать содержимое классов и вызывать произвольные методы во время выполнения с помощью рефлексии\cite{jvm:reflection}. Во время выполнения из JVM можно получить информацию о том, какие методы присутствуют в конкретном объекте и их сигнатуру. У каждого объекта в JVM есть поле с именем class, откуда можно получить объект типа Class$\langle$?$\rangle$. Он хранит множество дополнительной информации об объекте. В этом объекте есть методы для получения списка методов. С каждым методом хранится информация об имени и типе. Существует возможность вызвать полученный метод, при этом передав объект на котором производится вызов и массив типа Object с аргументами. Так как Object ссылочный тип, все примитивные аргументы оборачиваются. Поиск и вызов метода могут занимать длительное время: необходимо выполнить поиск по имени и выполнить проверку типов для всех аргументов. Если при вызове метода происходит исключительная ситуация, то метод порождает исключение типа InvocationTargetException причиной которого является исходное исключение.

С помощью рефлексии можно получить доступ к полям, которые не доступны из-за модификатора доступа. Для этого существует флаг доступности и методы, позволяющие его прочитать или изменить. Если попытаться вызывать недоступный метод, произойдёт исключение SecurityException. Изменив флаг доступа, можно обойти проверки и вызвать метод. Данный механизм был предложен к исключению из JRE 9 поэтому его использование не рекомендуется.

\paragraph{Библиотека invoke}
Для платформы JVM существует несколько динамических языков. Изначально их подержка осуществлялась с помощью механизма рефлексии. Данный подход накладывает значительные ограничения на производительность. Разработчики платформы внесли предложение Java Specification Request(JSR) 292, которое расширяет спецификацию JVM, добавляя туда возможности для работы динамических языков\cite{jvm:jsr292}. Предложение было принято и добавлено в спецификацию, начиная с версии 7.

JSR 292 содержит в себе новую инструкцию для вызовов invokedynamic и библиотеку для работы с ссылками на функции. Рассмотрим библиотеку подробнее. Два основных класса которые она содержит: Lookup и MethodHandle. Первый необходим для получения ссылок на методы. Его главное отличие от поиска с помощью рефлексии в том, что он учитывает области видимости методов и полей. Результатом поиска является MethodHandle. MethodHandle - это класс, который является прямой ссылкой на метод. При вызове этого метода не происходит проверок типов аргументов, проверки возможности вызова. Данная процедура переносится на стадию поиска. Благодаря этому ожидается что поиск будет дольше, а вызов быстрей. Помимо этого существует возможность манипуляции над аргументами: можно вставить аргумент на какую-то позицию. Существует возможность вызова с автоматическим преобразованием типов аргументов.

Рассмотрим подробнее инструкцию invokedynamic. Эта инструкция принимает на вход ссылку на специальный статический метод, который называется bootstrap методом. Этот метод определяется разработчиком и вызывается только при первой интерпретации инструкции. Результат вызова этого метода сохраняется внутри виртуальной машины и не вычисляется при следующем обращении. Метод имеет специальную сигнатуру: ему передаётся экземпляр класса Lookup и произвольный набор пользовательских параметров. Типы всех параметров должны быть из следующего набора типов: Type, MethodHandle, String, примитивные типы, массивы примитивных типов. Данный метод обязан возвращать объект типа CallSite. Данный объект может быть любым CallSite из библиотеки примитивов: ConstantCallSite, MutableCallSite и т.д.

В отличии от рефлексии, управление модификаторами доступа не предусмотрено. Все вызовы функций через класс MethodHandle привязаны к месту вызова в котором был создан Lookup объект, более того невозможно получить метод который недоступен в месте вызова из-за модификаторов доступа.

Если при внутри вызванной функции происходит исключение, его передача осуществляется как есть.

Таким образом можно получить функциональность схожую с рефлексией, но сделанную специально для динамических вызовов.
