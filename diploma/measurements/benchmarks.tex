\subsection{Рассмотренные тесты}
В ходе тестирования работы протоколов было написано множество тестов производительности. В данном разделе приведены тесты интересные с точки зрения сравнения реализации протоколов в \lang{Kotlin} с другими реализациями, а так же тесты, демонстрирующие типичные сценарии использования протоколов в реальном окружении.

\subsubsection{Сравнение времени работы методов с различным числом аргументов}
Одной из особенностей прототипа была возможность создания только одного метода с одним аргументом. После реализации полноценной поддержки протоколов, была выявлена зависимость времени вызова метода от числа аргументов. В случаях использования библиотеки вызовов, с ростом числа аргументов, время работы было значительно ниже чем с использованием библиотекой рефлексии. На рисунке \ref{plot:bench:argsCount} приведено сравнение реализаций с помощью библиотеки вызовов и рефлексии с использованием целевых объектов одного типа. В качестве кеша поиска использовалась хеш-таблица неограниченного размера.

\begin{figure}
\caption{\label{plot:bench:argsCount}Зависимость времени вызова от числа аргументов.}
\begin{tikzpicture}
\begin{axis}[
 legend pos = north west,
 legend cell align = left,
 %height = 0.6\paperheight,
  width = 0.75\paperwidth,
  xlabel = Количество аргументов,
  ylabel = Время работы (нс)
]
\legend{
  Библиотека вызовов,
  Рефлексия
};
\addplot coordinates {
  (0, 8.263) (1, 8.378) (2, 8.613) (3, 8.538) (4, 8.86) (5, 8.76) (10, 9.624) (15, 10.393) (20, 11.237)
};
\addplot coordinates {
  (0, 9.394) (1, 11.64) (2, 12.612) (3, 14.06) (4, 24.487) (5, 29.844) (10, 54.528) (15, 79.591) (20, 110.899)
};

\end{axis}
\end{tikzpicture}
\end{figure}

Данное поведение объясняется способом работы с аргументами у различных библиотек. В библиотеке рефлексии аргументы передаются в массиве, как набор ссылок типа \term{Object}. При каждом вызове необходимо проверить, подходит ли тип приведённого аргумента к типу вызова. Более того, необходимо время на выделение и заполнение массива аргументов на стеке.

В случае библиотеки вызовов проверка типов произошла во время поиска, поэтому дополнительные время работы слабо зависит от количества аргументов.

Подробное сравнение реализаций с учётом использования различного кеширования приведено в таблице \ref{table:bench:argsCount}

\subsubsection{Сравнение времени работы вызова метода с различным числом целевых объектов}
Одной из проблем при использовании протоколов является выбор размера кеша. С фиксированным размером кеша, большое количество типов в одном месте вызова метода протокола может значительно повлиять на  производительность. С другой стороны чем больше размер кеша, тем дольше осуществляется поиск в нём.

Для сравнения производительности протоколов с различным размером кеша и разным количеством целевых объектов был написан тест в котором на списке из фиксированного числа объектов типа протокола вызывается один метод. В списке содержаться объекты типа протокола различных типов с точки зрения виртуальной машины. В каждом тесте был использован список фиксированной длины $10^5$, равномерно перемешанных элементов. На каждом объекте вызывался метод без аргументов. Результаты измерений приведены на рисунке \ref{plot:bench:targetCount}.
\begin{figure}
\caption{\label{plot:bench:targetCount}Зависимость времени вызова от количества целевых объектов.}
\begin{tikzpicture}
\begin{axis}[
 legend pos = north west,
 legend cell align = left,
 %height = 0.6\paperheight,
  width = 0.75\paperwidth,
  xlabel = Количество целевых объектов в коллекции,
  ylabel = Время работы (нс)
]
\legend{
  ok
};
\addplot coordinates {
};

\end{axis}
\end{tikzpicture}
\end{figure}

% написать вывод
Подробные результаты измерений приведены в таблице \ref{table:bench:targetCount}.

\subsubsection{Сравнение реализаций в различных языках}
Для сравнения полученной реализации с другими языками необходим тест, который будет отражать случаи реального использования протоколов в программах. Одним из таких случаев использования служит объявление интерфейса \term{Comarable} протоколом. Использование протокола \term{Comparable} позволят использовать любые объекты, обладающие оператором сравнения, без явного наследования.

На основе данного теста был написан тест сортирующий числа с помощью сортировки слиянием\cite{merge_sort}. В качестве сравниваемых объектов выступают объекты типа протокола, содержащего оператор сравнения. В качестве реализации были выбраны 3 \tool{JVM} языка: \lang{Scala}, \lang{Whiteoak}, \lang{Kotlin}. Для компиляции \lang{Kotlin} используется реализация с использованием библиотеки вызовов и хеш-таблицей в качестве кеша. Результаты измерений приведены на рисунке \ref{plot:bench:mergeSort}.

\begin{figure}
\caption{\label{plot:bench:mergeSort} Сортировка слиянием}
\begin{tikzpicture}
\begin{axis}[
 legend pos = north west,
 legend cell align = left,
  width = 0.75\paperwidth,
  xlabel = log(размер входа),
  ylabel = Время работы (мкс)
]
\legend{
  Kotlin,
  Scala,
  Whiteoak
};
\addplot coordinates {
  (1, 0.572) (2, 9.53) (3, 126.669) (4, 1532.128) (5, 18717.642)
};
\addplot coordinates {
  (1, 0.592) (2, 10.435) (3, 128.85) (4, 1527.313) (5, 18067.048)
};
\addplot coordinates {
  (1, 0.464) (2, 7.996) (3, 109.161) (4, 1304.565) (5, 16262.484)
};

\end{axis}
\end{tikzpicture}
\end{figure}

Данное измерение демонстрирует, что при малом количестве аргументов все реализации имеют константные накладные расходы и работают примерно одно время. Подробное сравнение реализаций приведено в таблице \ref{table:bench:mergeSort}.

\subsubsection{Сравнение вариантов кеширования}

% foreword about call target cache size

\begin{figure}
\caption{\label{plot:bench:cachetype} Зависимость времени работы от количества целевых объектов}
\begin{tikzpicture}
\begin{axis}[
 legend pos = north west,
 legend cell align = left,
  width = 0.75\paperwidth,
  xlabel =  Количество типов,
  ylabel = Время работы (нс)
]
\legend{
  OK
};
\addplot coordinates {
};
\end{axis}
\end{tikzpicture}
\end{figure}

% conclusion about cache type selection
% cache selection recomendations
Подробные измерения для различных конфигураций компилятора приведены в таблице \ref{table:bench:multithread}.

% foreword about synchronization type in best case

\begin{figure}

\caption{\label{plot:bench:cachetype} Зависимость времени работы от типа синхронизации}
\begin{tikzpicture}
\begin{axis}[
 legend pos = north west,
 legend cell align = left,
  width = 0.75\paperwidth,
  xlabel =  Количество типов,
  ylabel = Время работы (нс)
]
\legend{
  OK
};
\addplot coordinates {
};
\end{axis}
\end{tikzpicture}
\end{figure}

% conclusion about synchronization time.
% notation about complex measurements in maximum workload scenario
% cache selection recomendations
