\subsection{Рассмотренные тесты}
В ходе тестирования работы протоколов было написано множество тестов производительности. В данном разделе приведены тесты интересные с точки зрения сравнения реализации протоколов в \lang{Kotlin} с другими реализациями, а так же тесты демонстрирующие типичные сценарии использования протоколов в реальном окружении.

\subsubsection{Сравнение времени работы методов с различным числом аргументов}
Одним из ограничений прототипа была возможность создания только одного метода с одним аргументом. После реализации полноценной поддержки протоколов, была выявлена зависимость времени вызова метода от числа аргументов. В случаях использования библиотеки вызовов, с ростом числа аргументов, время работы было значительно ниже чем с использованием библиотекой рефлексии. На рисунке \ref{plot:bench:argsCount} приведено сравнение реализаций с помощью библиотеки вызовов и рефлексии с использованием целевых объектов одного типа. В качестве кеша поиска использовалась хеш-таблица неограниченного размера.

\begin{figure}
\caption{\label{plot:bench:argsCount}Зависимость времени вызова от числа аргументов.}
\begin{tikzpicture}
\begin{axis}[
 legend pos = north west,
 legend cell align = left,
 %height = 0.6\paperheight,
  width = 0.75\paperwidth,
  xlabel = Количество аргументов,
  ylabel = Время работы (нс)
]
\legend{
  Библиотека вызовов,
  Рефлексия
};
\addplot coordinates {
  (0, 8.263) (1, 8.378) (2, 8.613) (3, 8.538) (4, 8.86) (5, 8.76) (10, 9.624) (15, 10.393) (20, 11.237)
};
\addplot coordinates {
  (0, 9.394) (1, 11.64) (2, 12.612) (3, 14.06) (4, 24.487) (5, 29.844) (10, 54.528) (15, 79.591) (20, 110.899)
};

\end{axis}
\end{tikzpicture}
\end{figure}

Данное поведение объясняется способом работы с аргументами у различных библиотек. В библиотеке рефлексии аргументы передаются в массиве, как набор ссылок типа \term{Object}. При каждом вызове необходимо проверить, подходит ли тип приведённого аргумента к типу ввызова. Более того необходимо время на выделение и заполнение массива аргументов на стеке.

В случае библиотеки вызовов проверка типов произошла во время поиска, поэтому дополнительные время работы слабо зависит от количества аргументов.

Подробное сравнение реализаций с учётом использования различного кеширования приведено в таблице \ref{table:bench:argsCount}

\subsubsection{Сравнение времени работы вызова метода с различным числом целевых объектов}
Количество типов объектов в одном месте вызова может значительно поменять производительность протоколов: на каждый новый тип необходимо выполнять поиск метода. Чем больше типов проходит через место вызова, тем больше времени необходимо для поиска в кеше.

Для сравнения производительности с разным количеством целевых объектов был написан тест в котором фильтруется список объектов типа протокола. В списке содержаться объекты типа протокола различных типов с точки зрения виртуальной машины. В каждом тесте был использован список фиксированной длины на 100000 равномерно перемешанных элементов. На каждом объекте вызывался метод без аргументов. Результаты измерений приведены на рисунке \ref{plot:bench:targetCount}.
\begin{figure}
\caption{\label{plot:bench:targetCount}Зависимость времени вызова от целевых объектов.}
\begin{tikzpicture}
\begin{axis}[
 legend pos = north west,
 legend cell align = left,
 %height = 0.6\paperheight,
  width = 0.75\paperwidth,
  xlabel = Количество целевых объектов в коллекции,
  ylabel = Время работы (нс)
]
\legend{
  ok
};
\addplot coordinates {
};

\end{axis}
\end{tikzpicture}
\end{figure}

Подробные результаты измерений приведены в таблице \ref{table:bench:targetCount}.

\subsubsection{Сравнение реализаций в различных языках}
Для сравнения полученной реализации с другими языками необходим тест, который будет отражать случаи реального использования протоколов в программах. Одним из таких случаев использования служит объявление интерфейса \term{Comarable} протоколом. Использование протокола \term{Comparable} позволят использовать любые объекты, обладающие оператором сравнения, без явного наследования.

На основе данного теста был написан тест сортирующий числа с помощью сортировки слиянием\cite{merge_sort}. В качестве сравниваемых объектов выступают объекты типа протокола, содержащего оператор сравнения. В качестве реализации были выбраны 3 \tool{JVM} языка: \lang{Scala}, \lang{Whiteoak}, \lang{Kotlin}. Для компиляции \lang{Kotlin} используется реализация с использованием библиотеки вызовов и хеш-таблицей в качестве кеша. Результаты измерений приведены на рисунке \ref{plot:bench:mergeSort}.

\begin{figure}
\caption{\label{plot:bench:mergeSort} Сортировка слиянием}
\begin{tikzpicture}
\begin{semilogyaxis}[
 legend pos = north west,
 legend cell align = left,
  width = 0.75\paperwidth,
  xlabel = log(размер входа),
  ylabel = Время работы (мкс)
]
\legend{
  Kotlin,
  Scala,
  Whiteoak
};
\addplot coordinates {
  (1, 0.572) (2, 9.53) (3, 126.669) (4, 1532.128) (5, 18717.642)
};
\addplot coordinates {
  (1, 0.592) (2, 10.435) (3, 128.85) (4, 1527.313) (5, 18067.048)
};
\addplot coordinates {
  (1, 0.464) (2, 7.996) (3, 109.161) (4, 1304.565) (5, 16262.484)
};

\end{semilogyaxis}
\end{tikzpicture}
\end{figure}

Данное измерение демонстрирует, что при малом количестве аргументов все реализации имеют константные накладные расходы и работают примерно одно время. Подробное сравнение реализаций приведено в таблице \ref{table:bench:mergeSort}.

\subsubsection{Вызов метода протокола из разных потоков}
Одной из интересных харрактеристик работы является время вызова вызов метода протокола в одном месте вызова из нескольких потоков, без их прямого взаимодействия. Для этого тест вызывающий метод протокола был запущен из нескольких потоков. Для вызова использовался метод протокола с тремя аргументами. Результаты измерений приведены в таблице \ref{plot:bench:multithread}.

\begin{figure}
\caption{\label{plot:bench:multithread} Вызов метода из разных потоков}
\begin{tikzpicture}
\begin{axis}[
 legend pos = north west,
 legend cell align = left,
  width = 0.75\paperwidth,
  xlabel = Число потоков,
  ylabel = Время работы (нс)
]
\legend{
  OK
};
\addplot coordinates {
};
\end{axis}
\end{tikzpicture}
\end{figure}

Подробные измерения для различных конфигураций компилятора приведены в таблице \ref{table:bench:multithread}.
