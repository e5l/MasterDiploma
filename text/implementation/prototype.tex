\subsection{Прототип}

Детальнее рассмотрим требования, которые должна соблюдать реализация.

\begin{itemize}
\item Язык Kotlin совместим с Java. Это значит, что объекты из языка Kotlin должны быть корректными объектами для языка Java и в обратную сторону. Одной из важных особенностей, которую хочется сохранить - это идентичность объекта, то есть приведение к структурному типу должно не модифицировать ссылку на объект.
\item Другим важным требованием является возможность использования структурных типов как в качестве типов коллекций, так и в качестве элементов существующих коллекций. Таким образом необходимо, чтоб структурные типы поддерживали типовые параметры.
\item Протоколы не должны вносить ощутимых расходов на потребление памяти и время работы при приведении типов и вызове метода.
\item Возможности использование структурных типов должны быть схожи с обычными типами.
\item По возможности необходимо избегать генерации кода в процессе выполнения
\end{itemize}

Вариант в котором структурный тип оборачивается в класс обёртку не подходит. При таком подходе теряется равеноство ссылок между исходным объектом и обёрнутым. Поэтому необходимо рассматривать подходы, при которых используются исходные ссылки на объект.

Переформулируя получаем что для реализации структурных типов необходимо уметь производить поиск и вызов любой функции на произвольном объекте. Такой функциональности можно добиться используя одну из двух стандартных библеотек: библиотеку рефлексии или библиотеку invoke. Поскольку обе библиотеки предоставляют схожую функциональность, выбор между ними сводится к поиску более производительного решения. Для того чтоб выбрать между ними реализован прототип, который осуществляет генерацию байткода для двух подоходов.

\subsubsection{Реализация с помощью рефлексии}
Для каждого места вызова генерируется статический метод. Этот метод принимает на вход объект на котором происходит вызов и возращает экземпляр класса Method. После этого все аргументы упаковываются в массив и вызывается метод invoke, который делает вызов нужного метода и сохраняет на стек результат. Поскольку сигнатура метода invoke не типизирована, то необходимо выполнить приведение типов.

\subsubsection{Реализация с помощью invokedynamic}
Рассмотрим реализацию с помощью invokedynamic. Аналогично предыдущему варианту, для каждого места вызова генерируется статический метод. В этом вызове происходит вызов инструкции invokedynamic, которой передаётся ссылка на вспомогательный статический метод и тип вызываемого метода. Внутри вспомогательного метода создаётся объект типа ConstantCallSite который содержит в себе вспомогательный класс, содержащий методы отвечающие за поиск нужного метода.

\subsubsection{Сравнение производительности}

Для реализации было предположено что типов, на которых делается вызов(в одном месте вызова), будет существенно меньше чем самих вызовов. Поиск метода выполняется не на самом объекте, а на его типе. Поэтому для каждого типа, на котором происходит вызов, храним найденный метод. Это позволит сильно сохранить время вызова.

\paragraph{Условия тестирования}