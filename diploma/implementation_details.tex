\section{Особенности реализации}
Рассмотрим детали реализации протоколов в \lang{Kotlin}. Основная часть реализации заключается в механизме вызова метода. Проблема заключается в том, что типов виртуальной машины(реальных типов методов) может быть не достаточно для выполнения корректного вызова. Идея реализации состоит в том, что во время компиляции вся информация о типах, необходимая в процессе выполнения для вызова метода, отдельно сохраняется в сгенерированном байткоде для использования во время вызова. Информация о том, какой метод необходимо вызывать выясняется в момент выполнения.

\subsection{Компиляция}
Для корректной работы протоколов в языке необходима генерация байткода в процессе компиляции. Реализация протоколов добавляет необходимость в введении новой разновидности типов, поэтому необходима модификация существующего алгоритма проверки типов для корректного приведения традиционных типов к типам протокола. Помимо проведения проверок, так же необходима генерация кода для вызова методов. Как было замечено ранее, было реализовано два независимых генератора кода в компиляторе для различных подходов: библиотеки рефлексии и библиотеки вызовов.

\subsubsection{Проверка типов} При написании программы, тип протокола можно получить только с помощью приведения типа: ручного или автоматического. При приведении типов компилятор обязан проверять условие подтипизации: является ли тип присваиваемого объекта подтипом целевого. В случае если целевой тип является протоколом, обычная проверка заменяется проверкой вложенности типов.

Для того чтоб проверить вложенность присваиваемого типа в целевой, нужно убедиться, что для каждого метода целевого типа существует аналогичный метод с таким же именем, тип которого является подтипом исходного метода. Тип возвращаемого значения может быть более конкретным.

При проверке типов могут встречаться типовые параметры. В данном контексте возможны две ситуации: типовой параметр имеет подстановку, типовой параметр не имеет подстановки. В первом случае, проверка типов происходит так, будто бы вместо типового параметра стояло подставленное значение. Данная подстановка является ожидаемой, с точки зрения использования, но, может быть, некорректной для сгенерированного кода во время вызова. Эта ситуация будет разобрана подробнее в разделе \ref{runtime_info}. Если подстановка для типового параметра отсутствует, он рассматривается как тип \term{Object}.

Отдельно стоит упомянуть про отсутствие подтипизации на методах, в случае, если аргументы не совпадают, но являются надтипами аргументов целевого метода. Данное поведение разрешено во многих функциональных языках, однако, с точки зрения разработчика, такое поведение может быть неоднозначным и, поэтому, запрещено на уровне проверки типов.

В компилятор были добавлены соответствующие сообщения об ошибке компиляции, в случае, если проверка типов завершается ошибкой при проверке протоколов.

\subsubsection{Генерация байткода}
Рассмотрим как происходит трансляция протоколов в байткод виртуальной машины. При генерации байткода тип протокола заменяется на тип \term{Object}. Заметим, что такой переход корректен с точки зрения приведения типов, так как \term{Object} является базовым типом для любого типа в виртуальной машине. Таким образом информация о протоколах отсутствует во время выполнения. В результате стирания типов протоколов не требуется генерировать дополнительное приведение типов, оно происходит автоматически.

Рассмотрим генерацию байткода для вызова методов. Для каждого места вызова метода протокола внутри соответствующего класса генерируется специальный статический метод. Данный метод принимает объект, на котором происходит вызов и возвращает экземпляр класса \term{MethodHandle} или \term{Method}, в зависимости от выбранного способа реализации.

Внутри статического метода генерируется вызов инструкции \term{invokedynamic} со следующими аргументами:
\begin{itemize}
  \item объект типа \term{Handle} - ссылка статический метод \term{getBootstrap} класса стандартной библиотеки \term{ProtocolCallSite}, сконструированный во время компиляции;
  \item строка с именем вызываемого метода;
  \item тип вызываемого метода.
\end{itemize}

Данный метод будет вызван только в первый раз, затем результат вызова будет сохранён в виртуальной машине и возвращён при следующих вызовах. Результатом данного вызова является объект типа \term{ProtocolCallSite}. Так как данный объект привязан к месту вызова, он является удобным для хранения кеша. На полученном объекте типа \term{ProtocolCallSite} генерируется вызов метода \term{getMethod}(или \term{getReflectMethod}). Механизм работы данных методов рассмотрен в разделе \ref{runtime_info}. Результатом вызова является ссылка на объект типа \term{MethodHandle} или \term{Method}, которая и возвращается из статического метода.

\subsection{Поддержка времени выполнения} \label{runtime_info}
Для поддержки времени выполнения в стандартную библиотеку был добавлен класс \term{ProtocolCallSite}. Основная функциональность данного класса - это поиск и кеширование метода. Как было рассмотрено ранее, имя и тип вызываемого метода были сохранены во время компиляции и переданы данному классу при создании. Помимо этого, с помощью \tool{JVM}, в класс передаётся экземпляр класса \term{Lookup} из библиотеки вызовов, привязанный к месту вызова инструкции \term{invokedynamic}.

\subsubsection{Поиск подходящего метода}
По сохранённой информации, во время выполнения, можно выполнить поиск метода. В библиотеках интроспекции присутствуют методы для поиска метода по имени и типу, но использование их напрямую связано с рядом проблем.

Одной из проблем является невозможность вызова метода типа, скрытого модификатором доступа. Рассмотрим дизайн типичного библиотечного интерфейса \term{List}. Интерфейс класса объявлен публичным. Однако библиотечные методы (например \term{Arrays.asList}) возвращают экземпляр приватного класса, приведённый к типу интерфейса. При обращении к полю \term{class}, данного объекта, получаем ссылку на информацию о приватном классе. Если попытаться вызвать метод этого класса произойдёт исключение \term{SecurityException}. Аналогичную проблему в \lang{Scala} решают с помощью смены модификатора доступа во время выполнения.

Другой проблемой является необходимость соответствия запрашиваемого типа с тем, что присутствует в объекте. Во время использования примитивных типов, при компиляции может быть сохранён ссылочный или примитивный тип, в зависимости от вызова. Но не известно какой метод с каким типом является ожидаемым во время выполнения. Например, при использовании класса с параметрическим типом, может присутствовать метод с параметрическим аргументом типа \term{Int}. При трансляции, параметрический тип станет типом \term{Object}, в то же время, объект мог быть приведён к типу протокола с ожидаемым типом \term{Int}.
Из описанных выше проблем следует, что встроенный в библиотеки поиск метода не подходит для реализации, поэтому было принято решение самостоятельно реализовать поиск метода с помощью библиотеки рефлексии, который бы учитывал все особенности поиска методов для протоколов. Результатом такого поиска является экземпляр класса \term{Method}, который, в случае необходимости, можно привести к объекту типа \term{MethodHandle}, с помощью имеющегося экземпляра класса \term{Lookup}.

Поиск метода разбивается на две части: выбор метода в объекте для вызова, поиск доступного метода для вызова.

\paragraph{Поиск подходящего метода для вызова}
С помощью библиотеки рефлексии возможно запросить все методы объекта. Заметим, что для получения подходящего метода среди всех методов, можно выполнить разновидность алгоритма выбора перегрузки. Рассмотрим используемый алгоритм детальнее: для каждого метода с подходящим именем считаем вектор расстояния по типам аргументов. В качестве образцового вектора используем тот, что был сохранён во время компиляции. Для оценки расстояния между аргументами используем следующую градацию:

\begin{itemize}
    \item Точное совпадение;
    \item Совпадение с точностью до оборачивания примитивных типов;
    \item Возможность присвоить объект необходимого типа в объект типа в аргументах.
\end{itemize}

В случае, если ни один из пунктов не выполняется, хотя бы для одного аргумента, метод считается не подходящим и исключается из рассмотрения. Среди всех методов выбираем тот, у которого в векторе все компоненты минимальны. Наличие и единственность такого метода проверяется в процессе компиляции при проверке типов.

\paragraph{Поиск доступного метода}
Найденный на этапе выбора метод, может быть не доступен для вызова из-за того, что его тип является скрытым модификатором доступа. Однако в момент приведения типа существовал доступный метод, не скрытый модификатором доступа. Это значит, что в иерархии наследования существует тип, не скрытый модификатором доступа, на котором можно сделать вызов. Искомый метод можно получить из обхода иерархии интерфейсов и базовых классов целевого типа, с поиском выбранного метода с помощью библиотеки рефлексии

\subsubsection{Кеширование результатов поиска метода}
Самый частый сценарий использования протокола - это вызов метода. Написание прототипа показало, что процедура вызова метода протокола выполняются заметно дольше, чем вызов аналогичного метода через интерфейс. Вызов метода протокола состоит из двух частей: первая часть заключается в выборе наиболее подходящего метода в объекте. Вторая в укладке аргументов и непосредственном вызове. Заметим, что результат поиска метода для одного типа метода и одного типа объекта будет всегда одинаков. Это значит, что можно запомнить результат поиска. Тогда выполнять поиск метода придётся только при первом вызове на одном типе.

Заметим, что во время компиляции одного места вызова тип вызываемого метода известен и не будет изменён во время выполнения.

Будем предполагать, что вызовов на протоколах будет происходить больше, чем типов объектов, на которых происходит вызов в одном месте вызова. Данное предположение вполне оправдано: оно начинает выполняться когда на одном типе дважды происходит вызов.

Исходя из сделанных предположений, можно сделать вывод о том, что использование кеша для хранения результата поиска может быть оправданно в случае, если обращение к кешу происходит быстрее чем поиск метода.

Для поиска оптимального кеша было реализовано 3 варианта кеширования:
\begin{itemize}
  \item ссылочный список;
  \item циклический массив с вытеснением последнего добавленного элемента;
  \item хеш-таблица.
\end{itemize}

Ключом для поиска является объект класса. Значением - экземпляр класса \term{Method} или \term{MethodHandle}, в зависимости от выбранной реализации. Размер кеша задаётся с помощью опций компиляции. По умолчанию размер кеша не ограничен(за исключением циклического списка, размер по умолчанию которого равен 20 элементам). Сравнение производительности кешей будет приведено в разделе \ref{measurements}.

\subsubsection{Вызов метода из нескольких потоков}
Механизм вызова метода объекта в \tool{JVM} не зависит от того из скольки потоков происходят вызовы. Поэтому, одним из требований вызова является вызов метода из нескольких потоков. Отличие вызова метода протокола от вызова обычного метода заключается в наличии изменяемого состояния: кеша. Это значит, что если работа с кешом является потокобезопасной, то вызов метода протокола тоже является потокобезопасным.

В нашем решении было рассмотрено 2 подхода к обеспечению потокобезопасности кеша: \term{synchronized}\cite{jvm:sync} конструкция и \term{read-write} блокировка. Конструкция \term{synchronized} является флагом метода и обеспечивает гарантию того, что помеченный метод исполняется только в одном потоке. Блокировка \term{read-write} реализована с помощью класса стандартной библиотеки \term{ReentrantReadWriteLock}\cite{jvm:rwlock}. Кеш протоколов состоит из двух методов, первый метод для поиска, второй для добавления элемента, следовательно можно производить раздельную блокировку для чтения и записи.

Каждый из подходов имеет свои преимущества и недостатки. Например, в \term{synchronized} методов блокировка может не производиться если работает только один поток, помимо этого может выполняться оптимистичная блокировка. В то же время \term{read-write} блокировка работает оптимально в случае, если происходят только чтения из кеша. Таким образом, если метод протокола уже был найден, блокировки не происходит.

\subsubsection{Опции компиляции}

Исходя из реализации, видно, что производительность протоколов сильно зависит от случаев использования. Например, использование протоколов в одном потоке избавит от необходимости использовать синхронизацию кеша, ограничение размера кеша уменьшит размер потребляемой памяти. Помимо этого, существует два независимых способа реализации: библиотека вызовов и рефлексия.

В связи с этим было принято решение предоставить пользователю контроль над параметрами компиляции протоколов с помощью опций компиляции. Так же это позволит детально измерить различные конфигурации протоколов для определения оптимальной реализации. При компиляции пользователю доступны следующие параметры:
\begin{itemize}
  \item \term{protocols-backend} - способ реализации;
  \item \term{protocols-cache} - используемый тип кеширования;
  \item \term{protocols-cache-size} - размер кеша.
\end{itemize}

Для выбора доступно несколько различных видов кеширования: ссылочный список, \term{LRU} кеш\cite{Johnson:1994:LOH:645920.672996} на основе хеш-таблицы, циклический массив. Для кеша доступна многопоточная реализация. В качестве опций по умолчанию используется однопоточный ссылочный список неограниченного размера.
