\subsection{Виртуальная машина Java}
В данном разделе рассматриваются особенности разработки компилятора для виртуальной машины Java(далее JVM). 

% [https://en.wikipedia.org/wiki/Java_virtual_machine]
% [http://dmoztools.net/Computers/Programming/Languages/Java/Implementations/]

Виртуальная машина JVM - это часть JRE ответственная за исполнение программ. JVM представляет из себя абстрактную виртуальную машину, описанную спецификацией\cite{jvm:specification}. В спецификации описаны набор инструкций, модель памяти, формат исполняемых файлов, ожидаемое поведение. Это значит что существует много различных реализаций JVM для разных платформ: HotSpot, IcedTea, Viva, Azul и т.д. 

JVM является стековой машиной. Это значит что программы исполняемые программы используют стек для передачи параметров вызовов. Единицей исполнения является классфайл. Классфайлы собираются в архивы формата jar.

На уровне JVM реализуется большинство языковых инструментов: наследование, объявление статических полей и методов, набор примитивных типов, механизм исключений. Все классы находятся в общей иерархии наследования: существует класс Object от которого по умолчанию наследуется каждый класс.

\subsubsection{Байткод виртуальной машины}
Рассмотрим подробно структуру классфайла. Каждый классфайл содержит в себе описание одного класса. В каждом классе хранится набор его полей, методов и информация о базовом классе. С каждым полем и методом хранится их тип. Исходный код метода состоит из последовательности однобайтовых(реже двухбайтовых) инструкций. 

Все инструкции строго типизированы. Существует набор встроенных и можно определять пользовательские. Встроенные типы бывают двух видов: примитивные типы и ссылочные типы. Примитивные типы передаются по значению, работы с ними более оптимальна: виртуальной машине не нужно обращаться по ссылке. Набор примитивных типов заранее определён и не может быть изменён пользователем. Для каждого примитивного типа существует парный ссылочный тип, который используется в случаях, когда необходима передача по ссылке. Существуют следующие типы примитивных типов: int, boolean, short; парные ссылочные типы: Integer, Boolean, Short соответственно.

Рассмотрим имеющийся набор инструкций. В байткоде присутствуют инструкции для работы с локальными переменными, для создания объектов и примитивных типов, арифметические операции, инструкции для вызова методов, условные переходы. Стоит отметить что полностью отсутствуют любые инструкции для прямого доступа к памяти: нельзя взять указатель на определённый адрес, перейти к исполнению адреса или прочитать адрес. Виртуальная машина полностью скрывает детали реализации аппаратной части в которой работает.

На уровне JVM поддерживается номинальная система типов и отношение наследования. По умолчанию каждый класс наследуется от класса Object. Для вызова метода необходимо знать тип объекта, в котором находится поле, имя метода и его сигнатуру. Для вызова методов используются invoke-инструкции. Существует несколько разных invoke-инструкций:
\begin{itemize}
    \item \textbf{invokespecial} используется для вызова конструкторов у не инициализированных объектов
    \item \textbf{invokevirtual} используется для вызова методов у класса,
    \item \textbf{invokestatic} используется для вызова статических методов
    \item \textbf{invokedynamic} используется для вызова различных методов, при этом механизм выбора метода определяется специальной функцией, которая передаётся в аргументах
\end{itemize}
Перед загрузкой класса виртуальная машина запустит верификатор, который проверит наличие методов и соответствие типов аргументов. Невозможно напрямую вызвать метод, если неизвесен реальный тип объекта.

\paragraph{Рефлексия}

Существует способ узнавать содержимое классов и вызывать произвольные методы во время выполнения с помощью рефлексии. Во время выполнения из JVM можно получить информацию о том, какие методы присутствуют в конкретном объекте и их сигнатуру. По имени и точной сигнатуре получить ссылку на метод и по ней сделать вызов. Вызов происходит с помощью метода invoke класса Method. Данный метод принимает объект на котором происходит вызов(далее ресивер) и массив с аргументами. Поиск метода может занимать длительное время. Вызов метода происходит дольше чем вызов с помощью invokevirtual поскольку при каждом вызове происходит заворачивание аргументов в массив и проверка типов. Если при вызове метода происходит исключительная ситуация, то метод порождает исключение типа InvocationTargetException причиной которого является исходное исключение.

% invokedynamic: boostrap method, lookup object, method handle
% рассказать про то что exception оборачивается
\paragraph{Инструкция invokedynamic}
% JSR, MethodHandle
Рассмотрим подробнее инструкцию invokedynamic. Эта инструкция принимает на вход ссылку на специальный статический метод. Этот метод определяется разработчиком и вызывается только при первой интерпретации инструкции. Результат вызова этого метода сохраняется внутри виртуальной машины и не вычисляется при следующем обращении. Метод имеет специальную сигнатуру: ему передаётся специальный словарь, к которому можно сделать запрос на наличие определённого метода или поля у объекта. Таким образом можно получить функциональность схожую с рефлексией, но выполняющую поиск метода и проверку типов только один раз.