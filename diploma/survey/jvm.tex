\subsection{Виртуальная машина Java}
В данном разделе рассматриваются особенности разработки компилятора для виртуальной машины \tool{Java}(далее \tool{JVM}).

Виртуальная машина \tool{JVM} - это часть \tool{JRE} ответственная за исполнение программ. \tool{JVM} представляет из себя абстрактную виртуальную машину, описанную спецификацией\cite{jvm:specification}. В спецификации описаны набор инструкций, модель памяти, формат исполняемых файлов, ожидаемое поведение. Это значит что существует много различных реализаций \tool{JVM} для разных платформ: \tool{HotSpot}, \tool{IcedTea}, \tool{Viva}, \tool{Azul} и т.д.

На уровне \tool{JVM} реализуется большинство языковых инструментов: классы и наследование, интерфейсы, объявление статических полей и методов, набор примитивных типов, механизм исключений. Объявление функций вне класса невозможно.

\subsubsection{Типизация}
В \tool{JVM} используется строгая статическая номинальная типизация. Это значит что все инструкции строго типизированы и наследование поддерживается на уровне виртуальной машины.

Все типы делятся на 2 класса: примитивные и ссылочные. \tool{JVM} определяет некоторое количество встроенных типов. Пользователи могут определять собственные типы.

Среди встроенных типов существует набор примитивных типов. Примитивные типы всегда передаются по значению. Это сделано из соображений производительности. Для встроенных примитивных типов существуют зеркальные ссылочные типы, для передачи по ссылке. Для таких типов существует встроенная конвертация из одного типа в другой. Существуют следующие типы примитивных типов: \term{int}, \term{boolean}, \term{short}; парные ссылочные типы: \term{Integer}, \term{Boolean}, \term{Short} соответственно. Объявить пользовательские примитивные типы невозможно.

\subsubsection{Исполнение кода}
Виртуальная машина \lang{Java} придерживается объектно ориентированной парадигме. Единицей исполнения является классфайл. Все классы находятся в общей иерархии наследования: существует класс встроенный Object от которого по умолчанию наследуется каждый класс.

Классфайлы собираются в архивы формата \term{jar}. При необходимости загрузчик классов виртуальной машины производит загрузку классфайла, поэтому по ходу выполнения программы возможно появление новых классов.

\subsubsection{Видимость}
Модификаторы видимости поддерживаются на уровне виртуальной машины. Существует 4 модификатора видимости: \operator{private}, \operator{public}, \operator{protected}, \operator{package}. \operator{Private} доступен только в том же окружении что и объявление, \operator{public} доступен везде, \operator{protected} доступен наследникам, package доступен в пределах пакета. Модификаторы доступа можно указать для объявлений классов и их полей.

\subsubsection{Работа с памятью}
Виртуальная машина инкапсулирует работу с сырой памятью внутри себя. Пользователю предоставляется возможность создать объект и работать с объектом по ссылке. Гарантий на то что объект имеет постоянный адрес в памяти нет. Как следстве невозможно прочитать или записать указанный адрес в памяти. Так же невозможно осуществить безусловный переход на какую либо область памяти в том числе и функцию. Механизм освобождения объектов не определён в спецификации, его реализация зависит от виртуальной машины. Ссылки не указывающие на какой-либо объект имеют значение \term{null}.

\subsubsection{Байткод виртуальной машины}
Рассмотрим подробно структуру классфайла. Каждый классфайл содержит в себе описание одного класса. В каждом классе хранится набор его полей, методов и информация о базовом классе. С каждым полем и методом хранится их тип. Исходный код метода состоит из последовательности однобайтовых(реже двухбайтовых) инструкций и секции локальных переменных.

Рассмотрим имеющийся набор инструкций. В байткоде присутствуют инструкции для работы с локальными переменными, для создания объектов и примитивных типов, арифметические операции, условные переходы.

В виртуальной машине поддерживается вызов методов. Существует несколько различных поведений вызова, для каждого из них существует своя инструкция:
\begin{itemize}
    \item \textbf{invokespecial} используется для вызова конструкторов у не инициализированных объектов, обращения к приватным полям текущего объекта и обращение к полям базового класса
    \item \textbf{invokevirtual} используется для вызова методов у класса
    \item \textbf{invokestatic} используется для вызова статических методов
    \item \textbf{invokedynamic} инструкция добавленная для вызова функций в динамических языках, будет рассмотрена далее
\end{itemize}

Вызов метода возможен только в том случае, когда его тип и имя возможны во время компиляции. Перед загрузкой класса виртуальная машина запустит верификатор, который проверит наличие методов и соответствие типов аргументов.

\subsubsection{Библиотеки для интроспекции}
Для получения информации о методах класса во время выполнения существуют две стандартные библиотеки: библиотека \term{reflection} и библиотека \term{invoke}. Обе библиотеки имеют интерфейс на языке \lang{Java}.

\paragraph{Библиотека рефлексии}
Существует способ узнавать содержимое классов и вызывать произвольные методы во время выполнения с помощью рефлексии\cite{jvm:reflection}. Во время выполнения из \tool{JVM} можно получить информацию о том, какого типа объект, какие методы и поля присутствуют в конкретном объекте и их сигнатуру. У каждого объекта в \tool{JVM} есть поле с именем \term{class}, откуда можно получить объект типа \term{Class}. Он хранит множество дополнительной информации об объекте. В этом объекте есть методы для получения списка методов. С каждым методом хранится информация об имени и типе. Существует возможность вызвать полученный метод. Для этого на объекте типа Method вызывают метод \method{invoke}, куда передают объект на котором происходит вызов и массив объектов типа \term{Object} с аргументами для метода. Все примитивные типы должны быть обёрнуты в соответсвующие ссылочные. Прив вызове происходит проверка типов объекта и аргументов и проверка их числа. Поиск и вызов метода метода могут происходить длительное время: необходимо выполнить поиск по имени и выполнить проверку типов для всех аргументов. Если при вызове метода происходит исключительная ситуация, то метод порождает исключение типа \term{InvocationTargetException} причиной которого является исходное исключение.

При вызове происходит проверка модификаторов доступа. Если попытаться вызвать недоступный метод произойдёт исключение \term{SecurityException}. С помощью рефлексии можно получить доступ к полям, которые не доступны из-за модификатора доступа. Для этого существует флаг доступности и методы, позволяющие его прочитать или изменить. Изменив флаг доступа, можно обойти проверки и вызвать метод. Данный механизм несколько раз предлагался к удалению из \tool{JDK} и его использование не рекомендуется.

\paragraph{Библиотека invoke}
  Платформа JVM используется в качестве среды выполнения для некоторых динамических языков. Изначально их подержка осуществлялась с помощью механизма рефлексии. Данный подход не удобен с точки зрения реализации компилятора и накладывает значительные ограничения на производительность. Разработчики платформы внесли предложение \term{Java Specification Request}(\term{JSR}) \term{292}, которое расширяет спецификацию \tool{JVM} добавляя туда возможности для работы динамических языков\cite{jvm:jsr292}. Предложение было принято и добавлено в спецификацию, начиная с версии 7.

\term{JSR 292} содержит в себе новую инструкцию для вызовов \operator{invokedynamic} и библиотеку для работы с ссылками на функции. Рассмотрим библиотеку подробнее. Два основных класса которые она содержит: \term{Lookup} и \term{MethodHandle}. Первый необходим для получения ссылок на методы. Его главное отличие от поиска с помощью рефлексии в том, что он учитывает области видимости методов и полей. Результатом поиска является \term{MethodHandle}. \term{MethodHandle} - это класс, который является прямой ссылкой на метод. При вызове этого метода не происходит проверок типов аргументов, проверки возможности вызова. Данная процедура переносится на стадию поиска. Благодаря этому ожидается что поиск будет дольше, а вызов быстрей. Помимо этого существует возможность манипуляции над аргументами: можно вставить аргумент на какую-то позицию. Существует возможность вызова с автоматическим преобразованием типов аргументов.

Рассмотрим подробнее инструкцию \operator{invokedynamic}. Эта инструкция принимает на вход ссылку на специальный статический метод, который называется \operator{bootstrap} методом. Этот метод определяется разработчиком и вызывается только при первой интерпретации инструкции. Результат вызова этого метода сохраняется внутри виртуальной машины и не вычисляется при следующем обращении. Метод имеет специальную сигнатуру: ему передаётся экземпляр класса \term{Lookup} и произвольный набор пользовательских параметров. Типы всех параметров должны быть из следующего набора типов: \term{Type}, \term{MethodHandle}, \term{String}, примитивные типы, массивы примитивных типов. Данный метод обязан возвращать объект типа \term{CallSite}. Данный объект может быть любым \term{CallSite} из библиотеки примитивов: \term{ConstantCallSite}, \term{MutableCallSite} и т.д.

В отличии от рефлексии, управление модификаторами доступа не предусмотрено. Все вызовы функций через класс \term{MethodHandle} привязаны к месту вызова в котором был создан \term{Lookup} объект, более того невозможно получить метод который недоступен в месте вызова из-за модификаторов доступа.

Если при внутри вызванной функции происходит исключение его передача осуществляется как есть.
