\subsection{Реализация протоколов в компиляторе Kotlin}
В данном разделе будет рассказано о деталях реализации протоколов в компиляторе Kotlin. Сперва рассмотрена основная функциональность реализации, рассказано как решены проблемы встреченные в других реализациях. Затем будет рассказано про структуру и особенность реализации функциональности в самом компиляторе и стандартной библиотеке.

\subsubsection{Функциональность}
\subsubsection{Синтаксис}
Для поддержки протоколов в компиляторе был введён новый тип интерфейсов и добавлено ключевое слово protocol.

\begin{minted}{kotlin}
protocol interface Proto {
  fun id(i: Int): Int
}

class Impl {
  fun id(i: Int): Int = i
}

fun foo(arg: Proto) {
  println(arg.id(42))
}

foo(Impl())
\end{minted}

Таким образом протоколы объявляются как самостоятельный тип.

\paragraph{Разрешение перегрузок}
Рассмотрим проблему несовпадения типов при использовании примитивных типов. Поиск методов выполняется по точному типу функции. Мы проверяем что необходимый метод существует во время компиляции. Проблема возникает в том что при трансляции конечные типы не совпадают. Данную проблему можно решить во время выполнения. Для этого необходимо изменить поиск метода из библиотеки на алгоритм разрешения перегрузок во время выполнения.

\paragraph{Наследование и наличие типа}
Ещё одной из проблем при полном стирании типа является невозможность наследования: при наследовании необходимо написать тип родителя. Данную проблему можно решить частичным стиранием типа: тип интерфейса генерируется и используется для наследования, во всех остальных случаях тип стирается.

\paragraph{Операторы проверки и приведения типа}
Для обычных типов в Kotlin разрешено приведение или проверка любого объекта к любому типу. В большинстве случаев объекты реализующие протоколы не являются типами протоколов с точки зрения JVM. С такой данной точки зрения возможно два поведения: реальная проверка типов инструкцией JVM либо проверка соответствию протоколов во время выполнения. Оба способа возможно реализовать практически. С точки зрения пользователя каждое из поведений может являться не ожидаемым, поэтому было принято решение запретить использование протоколов в правой части операторов as и is. В тоже время разрешено присваивание объекта обычного типа к типу протокола если проверка ограничений на тип проходит во время компиляции.

Если извесен исходный тип объекта типа протокола, то можно выполнить приведение типов. Так же можно выполнить проверку типов на объекте типа протокола.

Таким образом существует возможность перехода от обычных типов к протоколам и от протоколов к обычным типам.

\paragraph{Типовые параметры}
Так как во время выполнения выполняется поиск перегрузок, ограничений на использование типовых параметров нет. Протоколы могут использовать типовые параметры точно так же как и обычные типы. Поддерживаются ковариантные и контрвариантные параметры и отношения на них.

\begin{minted}{kotlin}
class A<in T>
class B<out T>
protocol interface X<T>
...
val x: X<Int> = A<Int>()
val y: X<Int> = B<Int>()
\end{minted}

\subsubsection{Компилция}
В процессе компиляции необходимо выполнить проверку типов и сгенерировать код для выполнения. Как было отмечено ранее в компиляторе реализована поддержка двух независимых подходов: через рефлексию и с помощь библиотеки invoke.

\paragraph{Проверка типов}
Проверка типов одинакова для обоих подходов. Чтобы проверить являетс ли тип подтипом протокола выполняется поиск каждого метода протокола в необходимом типе. В случае присутствия шаблонных параметров происходит их подстановка. Проверка наличия подходящего метода схожа с аналогичной проверкой возможности переопределения метода при наследовании: у методов должны совпадать имя и тип. Теоретически возможна реализация более конкретная реализация протокола: когда типы аргументов методов в протоколе являются подтипами соответствующих аргументов в типе объекта, но данный случай довольно редкий и зарещён для более предсказуемого поведения.

\paragraph{Генерация кода}
Для каждого места вызова на уровне пакета генерируется специальный статический метод, который в зависимости от типа реализации возвращает либо объект типа Method для рефлексии, либо объект типа MethodHandle для библиотеки invoke. Было принято решение использовать invokedynamic для двух решений для генерации статического объекта типа ProtocolCallSite, привязанного к месту вызова на уровне виртуальной машины. Этот объект был добавлен в библиотеку времени выполнения. В нём реализована логика поиска метода и кэширование. После инструкции invokedynamic на полученном объекте вызывается поиск метода.

\subsubsection{Поддержка времени выполнения}
Для поиска и кэширования метода в во время выполнения в стандартную библиотеку был добавлен класс ProtocolCallSite. Основная функциональность данного класса - поиск метода. Имя и тип вызываемого метода был передан при создании экзэмпляра метода. Но как было замечено ранее тип реального метода может отличаться от вызываемого с точностью до стираемых и примитивных типов. Поэтому поиск метода происходит с помощью библиотеки рефлексии и алгоритма выбора перегрузки.

\paragraph{Выбор подходящего типа}
Поиск метода связан с решением некоторого количества проблем. Рассмотрим дизайн типичного библиотечного интерфейса List. Интерфейс класса объявлен публичным. Однако библиотечные методы(например Arrays.asList) возвращают экземпляр приватного класса, приведённый к типу интерфейса. При обращении к полю class данного объекта получаем ссылку на информацию о приватном классе. Если попытаться вызвать метод это класса произойдёт исключение SecurityException. 

Аналогичную проблему в Scala решают с помощью смены модификатора доступа. Данное решение является кандитатом на исключение из спецификации, поэтому является неприемлимым. 

Заметим что пользователю доступен метод, значит должен существовать доступный пользователю тип, на котором можно сделать вызов. Так же очевидно что доступный тип является надтипом полученного нами типа. Поэтому задача сводится к следующей: найти ближайший подходящий доступный метод среди типа и его надтипов. Данная задача решается с помощью объхода иерархии наследования в ширину и запуском механизма выбора перегрузки дял каждого встреченного типа.

\paragraph{Алгоритм выбора перегрузки}
Рассмотрим процесс выбора подходящего метода. Среди всех методов с необходимым именем, оставляем методы доступные для вызова пользователем. Для каждого такого метода считаем вектор расстояния по типам аргументов. В качестве образцового вектора используем тот, что был сохранён во время компиляции. Для оценки расстояния между аргументами используем следующую градацию:
\begin{itemize}
    \item Точное совпадение
    \item Совпадение с точностью до оборачивания примитивных типов
    \item Возможность присвоить объект необходимого типа в объект типа в аргументах
\end{itemize}

Среди всех методов выбираем тот, у которого в векторе все компоненты минимальны. Наличие и единственность такого метода гарантируется в процессе компиляции.

\subsubsection{Кэш}

\subsubsection{Опции компиляции}
%\paragraph{Разрешение перегрузок}
%Рассмотрим проблему несовпадения типов при использовании примитивных типов. Поиск методов выполняется по точному типу функции. Мы проверяем что необходимый метод существует во время компиляции. Проблема возникает в том что при трансляции конечные типы не совпадают. Данную проблему можно решить во время выполнения. Для этого необходимо изменить поиск метода из библиотеки на алгоритм разрешения перегрузок. Идея заключается в том, чтоб выбирать ближайшую по расстоянию функцию.
%
%Для выбора перегрузки, для каждого метода в классе с таким же именем считается вектор расстояния. Каждая компонента этого вектора - расстояние между типами аргументов в типе метода и типе сохранённом во время компиляции если они в одной иерархии наследования, в противном случаее -1. Из всех векторов выбирается тот, у которого все координаты не меньше чем у любого другого вектора. Наличие и единственность такого метода будут гарантированы во время компиляции при приведении типов.



% проверка типов - проверка возможности сделать оверрайд
% генерация интерфейса => анонимные имплементации
% райнтайм - выбор перегрузок
% кэш

