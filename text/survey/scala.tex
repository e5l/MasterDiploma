\subsubsection{Scala}
Рассмотрим реализацию протоколов в языке Scala. Scala компилируется в JVM байткод. Реализацию можно разделить на 2 смысловые части: проверку типов при компиляции и генерация байткода для вызова метода.

В Scala используется модификация алгоритма Хиндли-Милнера для типизации. Модификация заключается в проверке отношения наследования, поэтому для работы протоколов достаточно отключить проверку явного наследования.

Рассмотри генерацию байткода. В Scala типы протоколов существуют только во время компиляции. В байткоде не генерируется новый тип. В процессе компиляции, тип протокола стираются до типа Object. Для каждого места обращения к полю объекта генерируется статический метод, который выполняет вызов необходимого метода. В статическом методе происходит поиск нужного метода для вызова через рефлексию. Так как внутри вызова может произойти исключительная ситуация, в этом методе происходит обработка исключения и разворачивание исходного исключения из InvokationTargetException. Таким образом вызов дополнительного метода выглядит прозрачно для пользователя. Поиск метода может быть долгим, поэтому в реализации скала используют кэширование для найденного метода найденного метода: сперва запрос идёт в кеш и вслучае неуспеха происходит поиск. В связи с тем что во время выполнения отсутствуют типы - запрещено создание generic протоколов или использование в протоколах generic типов.

Внимательное тестирование подхода, используемого в Scala показало что есть возможность написать код, порождающий некоректное поведение и ошибку времени выполнения, несмотря на внешнюю корректность синтаксиса. Такое поведение связано с использованием примитивных типов в generic классах:

/*
source code:
class Impl[T] {
	fun x(i: T): T = i
}

class Main {
	type Proto = { def x(i: Int): Int }

	fun foo(arg: Proto) {
		print(arg.x(42))
	}

	fun main(args: Array[String]) {
		foo(Impl[Int]())
	}
}
*/

С точки зрения языка Scala такой код корректный. Он проходит проверку типов и компиляцию, но во время выполнения происходит искючительная ситуация. Причиной этому является не совпадение сигнатур методов. Во время генерации класса Impl тип T становится наиболее общим типом Object. В то же время для вызова в методе foo сгенерировался метод ищущий функции с типом Int. Поэтому в во время выполнения нужная функция в объекте Impl отсутствует и происходит исключение.
